# === PROJECT TABLE OF CONTENTS (143 files) ===
# Version: PROJECT_EXPORT_v1.4
#  - config.py
#  - const.py
#  - export_script.py
#  - game.py
#  - game_context.py
#  - main.py
#  - scene_manager.py
#  - settings.json
#  - world.py
#  - data\aging.json
#  - data\balancing.json
#  - data\breeding.json
#  - data\fish_defaults.json
#  - data\loot_tables.json
#  - data\pellets.json
#  - data\prices.json
#  - data\species.json
#  - data\tank_defaults.json
#  - data\ui_config.json
#  - ecs\__init__.py
#  - render\__init__.py
#  - render\asset_manager.py
#  - render\audio_manager.py
#  - render\renderer.py
#  - saves\__init__.py
#  - scenes\__init__.py
#  - scenes\base_scene.py
#  - scenes\tank_scene.py
#  - tests\__init__.py
#  - tests\conftest.py
#  - tests\helpers.py
#  - tests\test_age_health.py
#  - tests\test_collision_avoidance.py
#  - tests\test_config_loader.py
#  - tests\test_fish_window_thumbs.py
#  - tests\test_fsm_cruise.py
#  - tests\test_fsm_food_chain.py
#  - tests\test_modal_strict_blocking.py
#  - tests\test_movement_system.py
#  - tests\test_panel_manager_grid.py
#  - tests\test_placement_public.py
#  - tests\test_resize_system.py
#  - tests\test_right_click_cancel.py
#  - tests\test_smoke_startup.py
#  - tests\test_strict_modal.py
#  - tests\test_world_core.py
#  - utils\__init__.py
#  - utils\geometry.py
#  - utils\jsonio.py
#  - utils\rng.py
#  - utils\spatial.py
#  - utils\steering.py
#  - ecs\components\__init__.py
#  - ecs\factories\__init__.py
#  - ecs\factories\fish_factory.py
#  - ecs\fsm\__init__.py
#  - ecs\fsm\base_state.py
#  - ecs\fsm\chase_food_state.py
#  - ecs\fsm\cruise_state.py
#  - ecs\fsm\dead_state.py
#  - ecs\fsm\egg_state.py
#  - ecs\fsm\idle_state.py
#  - ecs\fsm\look_for_food_state.py
#  - ecs\systems\__init__.py
#  - ecs\views\__init__.py
#  - ecs\views\fish_view.py
#  - ecs\components\core\__init__.py
#  - ecs\components\core\bounds_component.py
#  - ecs\components\core\collider_component.py
#  - ecs\components\core\position_component.py
#  - ecs\components\core\sprite_component.py
#  - ecs\components\core\tank_component.py
#  - ecs\components\core\tank_label_component.py
#  - ecs\components\core\tank_ref_component.py
#  - ecs\components\core\tank_stats.py
#  - ecs\components\core\tank_style_component.py
#  - ecs\components\core\velocity_component.py
#  - ecs\components\fish\__init__.py
#  - ecs\components\fish\age_component.py
#  - ecs\components\fish\behavior_tuning.py
#  - ecs\components\fish\brain_component.py
#  - ecs\components\fish\breeding_component.py
#  - ecs\components\fish\health_component.py
#  - ecs\components\fish\hunger_component.py
#  - ecs\components\fish\motion_component.py
#  - ecs\components\fish\species_component.py
#  - ecs\components\fish\speed_intent_component.py
#  - ecs\components\fish\steering_intent_component.py
#  - ecs\components\fish\target_intent_component.py
#  - ecs\components\tags\__init__.py
#  - ecs\components\tags\affected_by_gravity.py
#  - ecs\components\tags\comfort_component.py
#  - ecs\components\tags\dead_component.py
#  - ecs\components\tags\food_pellet_component.py
#  - ecs\systems\ai\__init__.py
#  - ecs\systems\ai\behavior_system.py
#  - ecs\systems\ai\state_override_system.py
#  - ecs\systems\ai\state_transition_system.py
#  - ecs\systems\core\__init__.py
#  - ecs\systems\core\avoidance_system.py
#  - ecs\systems\core\collision_system.py
#  - ecs\systems\core\movement_system.py
#  - ecs\systems\core\resize_system.py
#  - ecs\systems\gameplay\__init__.py
#  - ecs\systems\gameplay\aging_system.py
#  - ecs\systems\gameplay\health_system.py
#  - ecs\systems\gameplay\hunger_system.py
#  - ecs\systems\gameplay\population_guard.py
#  - ecs\systems\physics\__init__.py
#  - ecs\systems\physics\gravity_system.py
#  - ecs\systems\renderers\__init__.py
#  - ecs\systems\renderers\cache.py
#  - ecs\systems\renderers\draw_sprite.py
#  - ecs\systems\renderers\geometry.py
#  - ecs\systems\renderers\overlay_food.py
#  - ecs\systems\renderers\overlay_labels.py
#  - ecs\systems\renderers\overlay_motion.py
#  - ecs\systems\rendering\__init__.py
#  - ecs\systems\rendering\fish_overlay_system.py
#  - ecs\systems\rendering\sprite_render_system.py
#  - ecs\systems\rendering\tank_render_system.py
#  - ecs\systems\ui\__init__.py
#  - ecs\systems\ui\cursor_system.py
#  - ecs\systems\ui\fish_inspector_system.py
#  - ecs\systems\ui\fish_window_system.py
#  - ecs\systems\ui\hotkeys_system.py
#  - ecs\systems\ui\input_router.py
#  - ecs\systems\ui\keyboard_system.py
#  - ecs\systems\ui\mouse_system.py
#  - ecs\systems\ui\placement_system.py
#  - ecs\systems\ui\ui_toolbar_system.py
#  - ecs\systems\ui\debug\__init__.py
#  - ecs\systems\ui\debug\debug_controller.py
#  - ecs\systems\ui\debug\debug_menu.py
#  - ecs\systems\ui\debug\debug_overlay_system.py
#  - ecs\systems\ui\debug\fish_info_system.py
#  - ecs\systems\ui\widgets\__init__.py
#  - ecs\systems\ui\widgets\grid_layout.py
#  - ecs\systems\ui\widgets\modal_window.py
#  - ecs\systems\ui\widgets\panel.py
#  - ecs\systems\ui\widgets\panel_manager_system.py
#  - ecs\systems\ui\widgets\scrollbox.py
#  - ecs\systems\ui\widgets\thumb_provider.py
# === FILE START: config.py ===
```python
# config.py
import json
import os
DEFAULT_CONFIG = {
    "screen_width": 1500,
    "screen_height": 1000,
    "fullscreen": False,
    "audio": {
        "enabled": True,
        "master_volume": 0.8,
        "num_channels": 8,
        "sounds": {
            "pellet_drop": [
                "assets/audio/shake1.wav",
                "assets/audio/shake2.wav",
                "assets/audio/shake3.wav"
            ],
            "bite": [                        # ← add this bank
                    "assets/audio/bite1.wav"
            ],
            "death": [                          # ← add this block
                    "assets/audio/death.wav"
            ]
        },
        "volumes": {
            "pellet_drop": 1.0,
            "bite": 1.0,
            "death": 1.0
        }
    }
}
# File next to config.py
CONFIG_PATH = os.path.join(os.path.dirname(__file__), "settings.json")
# [config.py] — validate/normalize user config; keep defaults on bad values
def load_config():
    if not os.path.exists(CONFIG_PATH):
        return DEFAULT_CONFIG.copy()
    try:
        with open(CONFIG_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
        final = DEFAULT_CONFIG.copy()
        final.update({k: v for k, v in data.items() if k in DEFAULT_CONFIG})
        # force types
        final["screen_width"]  = int(final["screen_width"])
        final["screen_height"] = int(final["screen_height"])
        final["fullscreen"]    = bool(final["fullscreen"])
        a = final.get("audio", {}) or {}
        a["enabled"]       = bool(a.get("enabled", True))
        a["master_volume"] = float(a.get("master_volume", 0.8))
        a["num_channels"]  = int(a.get("num_channels", 8))
        # normalize 'sounds' to dict[str, list[str]]
        sounds = a.get("sounds") or {}
        a["sounds"] = {str(k): list(v or []) for k, v in sounds.items()}
        # normalize 'volumes' to dict[str, float]
        vols = a.get("volumes") or {}
        a["volumes"] = {str(k): float(v) for k, v in vols.items()}
        final["audio"] = a
        return final
    except Exception as exc:
        print(f"⚠ Failed to load settings.json — using defaults. ({exc})")
        return DEFAULT_CONFIG.copy()
def save_config(config):
    """Write changes back to settings.json."""
    with open(CONFIG_PATH, "w") as f:
        json.dump(config, f, indent=4)
```
# === FILE END: config.py ===
# === FILE START: const.py ===
```python
"""
const.py
Engine-wide constants and debug toggles.
User settings should NOT be stored here.
"""
# === Display & Timing ===
FPS = 60
TICK_TIME = 1.0 / FPS
# === Colors ===
WHITE        = (255, 255, 255)
BLACK        = (0, 0, 0)
LIGHT_GREY   = (200, 200, 200)
DARK_GREY    = (50, 50, 50)
TRANSPARENT  = (0, 0, 0, 0)
COLORKEY     = (255, 0, 255)
BG_COLOR     = (40, 90, 160)
# === Render Layers ===
LAYER_BG       = 0
LAYER_TERRAIN  = 1
LAYER_ENTITIES = 2
LAYER_UI       = 3
# === Debug Flags (engine-side only; NOT user-configurable) ===
DEBUG_SHOW_BEHAVIOR_LABELS   = False
DEBUG_SHOW_STATS_BARS        = False
# Target lines (fish → its current target point)
DEBUG_SHOW_TARGET_LINES      = False
# Velocity & avoidance
DEBUG_SHOW_VELOCITY_ARROWS   = False
DEBUG_SHOW_AVOIDANCE_ARROWS  = False
# Food-specific debug
DEBUG_SHOW_FISH_VISION       = False   # cyan circles around fish (vision)
DEBUG_SHOW_PELLET_RADIUS     = False   # blue circles around pellets (sprite radius)
DEBUG_SHOW_FOOD_LINKS        = False   # orange line mouth → targeted pellet
DEBUG_SHOW_SPRITE_BORDER     = False
# Escape quits game in debug mode
DEBUG_ESCAPE_QUIT = True
```
# === FILE END: const.py ===
# === FILE START: export_script.py ===
```python
# export_script.py
import os
import re
PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
OUTPUT_FILE = os.path.join(PROJECT_ROOT, "project_export.txt")
# Ignore list
IGNORE_DIRS = {
    "venv", ".venv",
    "__pycache__", ".git", ".idea",
    ".mypy_cache", ".pytest_cache",
    "build", "dist"
}
# Add new non-Python extensions here
EXPORT_EXTENSIONS = {".py", ".json"}
VERSION_TAG = "PROJECT_EXPORT_v1.4"
# Optional clipboard support
try:
    import pyperclip  # noqa: F401
    _HAS_PYPERCLIP = True
except Exception:
    _HAS_PYPERCLIP = False
def is_ignored_dir(dirname: str) -> bool:
    return dirname.lower() in IGNORE_DIRS
def collect_files(root: str):
    """Collect python + json files."""
    collected = []
    for dirpath, dirnames, filenames in os.walk(root):
        dirnames[:] = [d for d in dirnames if not is_ignored_dir(d)]
        for filename in filenames:
            ext = os.path.splitext(filename)[1].lower()
            if ext in EXPORT_EXTENSIONS:
                full = os.path.join(dirpath, filename)
                rel = os.path.relpath(full, root)
                collected.append((rel, full))
    # deterministic ordering
    collected.sort(key=lambda x: (x[0].count(os.sep), x[0]))
    return collected
def compress_blank_lines(text: str) -> str:
    """Remove 2+ consecutive blank lines, reduce to max 1."""
    return re.sub(r"\n{2,}", "\n", text)
def build_table_of_contents(files):
    lines = [
        f"# === PROJECT TABLE OF CONTENTS ({len(files)} files) ===",
        f"# Version: {VERSION_TAG}",
        ""
    ]
    for path, _ in files:
        lines.append(f"#  - {path}")
    lines.append("")
    return "\n".join(lines)
def build_file_section(rel_path: str, full_path: str) -> str:
    """Read a file and wrap it."""
    try:
        with open(full_path, "r", encoding="utf-8") as f:
            code = f.read()
    except UnicodeDecodeError:
        code = "<Error reading file: non-UTF8 encoding>"
    code = compress_blank_lines(code)
    ext = os.path.splitext(rel_path)[1].lower()
    fence = "python" if ext == ".py" else "json" if ext == ".json" else ""
    return (
        f"# === FILE START: {rel_path} ===\n"
        f"```{fence}\n{code}\n```\n"
        f"# === FILE END: {rel_path} ===\n"
    )
def main():
    files = collect_files(PROJECT_ROOT)
    if not files:
        print("No files found.")
        return
    toc = build_table_of_contents(files)
    sections = [toc]
    for rel_path, full_path in files:
        sections.append(build_file_section(rel_path, full_path))
    final_text = "\n\n".join(sections)
    final_text = compress_blank_lines(final_text)
    with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
        out.write(final_text)
    # Clipboard copy happens *after* final_text exists, and only if available.
    if _HAS_PYPERCLIP:
        try:
            import pyperclip
            pyperclip.copy(final_text)
            print(f"Copied to clipboard ✓ ({VERSION_TAG})")
        except Exception as exc:
            print(f"⚠ Failed to copy to clipboard: {exc}")
    else:
        print("⚠ pyperclip not available; skipped clipboard copy.")
    size_kb = os.path.getsize(OUTPUT_FILE) / 1024
    print(f"Export complete: {len(files)} files, {size_kb:.1f} KB")
    print(f"Written to {OUTPUT_FILE}")
if __name__ == "__main__":
    main()
```
# === FILE END: export_script.py ===
# === FILE START: game.py ===
```python
# =========================
# file: game.py
# =========================
import pygame
import const
from game_context import GameContext
from scene_manager import SceneManager
from scenes.tank_scene import TankScene
from config import load_config
from render.audio_manager import AudioManager
class Game:
    def __init__(self):
        pygame.init()
        pygame.display.set_caption("Fish SIM")
        self.settings = load_config()
        w = self.settings["screen_width"]
        h = self.settings["screen_height"]
        fullscreen = self.settings["fullscreen"]
        flags = pygame.RESIZABLE
        if fullscreen:
            flags |= pygame.FULLSCREEN
        self.screen = pygame.display.set_mode((w, h), flags)
        self.clock = pygame.time.Clock()
        self.context = GameContext()
        self.context.assets.load_folder("assets/sprites")
        self.context.audio = AudioManager(self.settings)
        # Scene
        initial_scene = TankScene(self.context, self.screen)
        self.scene_manager = SceneManager(initial_scene)
        # Initial resize (so tank lays out once)
        sw, sh = self.screen.get_size()
        self.context.new_screen_w = sw
        self.context.new_screen_h = sh
        self.context.needs_resize = True
        self.dt = 1.0 / const.FPS
        self.accumulator = 0.0
    def run(self):
        while self.context.running:
            frame_time = self.clock.tick(const.FPS) / 1000.0
            self.context.fps = self.clock.get_fps()
            self.accumulator += frame_time
            for event in pygame.event.get():
                # --- FIX: honor OS window close (❌) ---
                if event.type == pygame.QUIT:
                    self.context.running = False
                    continue  # no further dispatch
                if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    if self.context.debug_escape_quit:
                        self.context.running = False
                if event.type == pygame.VIDEORESIZE:
                    self.screen = pygame.display.set_mode((event.w, event.h), pygame.RESIZABLE)
                    if hasattr(self.scene_manager.current_scene, "set_screen"):
                        self.scene_manager.current_scene.set_screen(self.screen)
                    self.context.new_screen_w = int(event.w)
                    self.context.new_screen_h = int(event.h)
                    self.context.needs_resize = True
                # Route once to the active scene
                self.scene_manager.handle_event(event)
            while self.accumulator >= self.dt:
                self.scene_manager.update(self.dt * self.context.time_scale)
                self.accumulator -= self.dt
            self.screen.fill(const.BG_COLOR)
            self.scene_manager.render(self.screen)
            pygame.display.flip()
        pygame.quit()
```
# === FILE END: game.py ===
# === FILE START: game_context.py ===
```python
# =========================
# file: game_context.py
# =========================
import const
from render.asset_manager import AssetManager
from utils.jsonio import load_json
import os
_BALANCING_DEFAULTS = {
    "movement_damping": 0.995,
    "wall_bounce": 0.30,
    "typical_max_speed": 40.0,
    "avoidance_margin": 20.0,
    "avoidance_max_strength": 0.25,
    "dead_sink_speed": 30.0,
    "state_speed_smoothing": 0.10,
    "idle_arrival_threshold": 6.0,
    "idle_bob_x_factor": 1.0,
    "idle_bob_y_factor": 0.8
}
_PELLET_DEFAULTS = {
    "sprite": "pellet",
    "width": 16,
    "height": 16,
    "radius_scale": 1.35,
    "nutrition": 40.0,
    "fall_speed": 60.0
}
_UI_DEFAULTS = {
    "render_cache_limit": 256,
    "ui_font_size": 14,
    "ui_bar_height": 4,
    "ui_bar_gap": 6,
    "ui_label_offset": 2,
    "ui_target_line_width": 1,
    "ui_velocity_arrow_scale": 0.5,
    "ui_avoidance_arrow_scale": 40.0,
    "ui_debug_border_width": 1,
}
# near other _DEFAULTS:
_AGING_DEFAULTS = {
    "elder_threshold_ratio": 0.80,
    "juvenile_threshold_ratio": 0.15,
    "elder_speed_multiplier_min": 0.70,
    "juvenile_speed_multiplier_min": 0.85,
    "elder_health_decay_at_max_per_sec": 0.04,
    "hard_death_at_lifespan": True,
    "egg_duration_sec": 12.0,
}
class GameContext:
    def __init__(self):
        self.running = True
        # Time scaling + pause
        self.time_scale = 1.0
        self._prev_time_scale = 1.0
        self.paused = False
        # Tank defaults (load file; fallback to prior hardcoded values)
        tank_defaults = load_json(os.path.join("data", "tank_defaults.json"), default={
            "logical_tank_width": 1000,
            "logical_tank_height": 600,
            "sand_top_ratio": 1.0
        })
        self.logical_tank_w = int(tank_defaults.get("logical_tank_width", 1000))
        self.logical_tank_h = int(tank_defaults.get("logical_tank_height", 600))
        # Used by pellet resting height, etc.
        self.sand_top_ratio = float(tank_defaults.get("sand_top_ratio", 1.0))
        # Resize state
        self.needs_resize = False
        self.new_screen_w = 0
        self.new_screen_h = 0
        # Computed tank transform
        self.tank_scale = 1.0
        self.tank_screen_x = 0
        self.tank_screen_y = 0
        self.tank_screen_w = self.logical_tank_w
        self.tank_screen_h = self.logical_tank_h
        self.swim_bottom_margin = int(tank_defaults.get("swim_bottom_margin", 64))
        # Debug flags (mirror const)
        self.show_behavior_labels   = const.DEBUG_SHOW_BEHAVIOR_LABELS
        self.show_stats_bars        = const.DEBUG_SHOW_STATS_BARS
        self.show_target_lines      = const.DEBUG_SHOW_TARGET_LINES
        self.show_velocity_arrows   = const.DEBUG_SHOW_VELOCITY_ARROWS
        self.show_avoidance_arrows  = const.DEBUG_SHOW_AVOIDANCE_ARROWS
        self.debug_sprite_border    = const.DEBUG_SHOW_SPRITE_BORDER
        self.debug_escape_quit      = const.DEBUG_ESCAPE_QUIT
        self.show_fish_vision       = const.DEBUG_SHOW_FISH_VISION
        self.show_pellet_radius     = const.DEBUG_SHOW_PELLET_RADIUS
        self.show_food_links        = const.DEBUG_SHOW_FOOD_LINKS
        self.show_debug_overlay     = False
        self.fps = 0.0
        # Data/config
        self.fish_defaults  = load_json(os.path.join("data", "fish_defaults.json"))
        self.species_config = load_json(os.path.join("data", "species.json"), default={})
        self.balancing      = load_json(os.path.join("data", "balancing.json"), default=_BALANCING_DEFAULTS)
        self.ui             = load_json(os.path.join("data", "ui_config.json"), default=_UI_DEFAULTS)
        self.pellets        = load_json(os.path.join("data", "pellets.json"), default=_PELLET_DEFAULTS)
        self.aging = load_json(os.path.join("data", "aging.json"), default=_AGING_DEFAULTS)
        self.breeding = load_json("data/breeding.json", default={
            "enabled": True,
            "mate_radius": 120.0,
            "pair_distance": 40.0,
            "courtship_time_sec": 6.0,
            "courtship_grace_sec": 0.3,
            "cooldown_sec": 30.0,
            "offspring_count_range": [1, 3],
            "min_health_ratio": 0.6,
            "min_hunger_ratio": 0.4,
            "max_population": 60
        })
        self.population_ok = True           # set by PopulationGuard
        self.test_seed = None
        # Assets
        self.assets = AssetManager()
        # --- UI/toolbar state ---
        self.feeding_enabled = False
        self.egging_enabled = False  # NEW: egg placement mode
        self.toolbar_button_rect = None  # feed button rect
        self.toolbar_egg_rect = None  # NEW: egg button rect
        # Optionally ensure UI defaults exist (used for egg sprite size)
        ui = self.ui or {}
        ui.setdefault("ui_egg_button_size", ui.get("ui_toolbar_button_size", 48))
        ui.setdefault("ui_egg_sprite_size", 28)  # fixed on-screen egg size (px)
        self.ui = ui
    def toggle_pause(self):
        # Why: keeps previous time_scale when unpausing.
        if not self.paused:
            self._prev_time_scale = self.time_scale
            self.time_scale = 0.0
            self.paused = True
        else:
            self.time_scale = self._prev_time_scale if self._prev_time_scale > 0 else 1.0
            self.paused = False
```
# === FILE END: game_context.py ===
# === FILE START: main.py ===
```python
from game import Game
if __name__ == "__main__":
    game = Game()
    game.run()
```
# === FILE END: main.py ===
# === FILE START: scene_manager.py ===
```python
# scene_manager.py
class SceneManager:
    def __init__(self, initial_scene):
        self.current_scene = initial_scene
    def switch(self, new_scene):
        self.current_scene = new_scene
    def handle_event(self, event):
        self.current_scene.handle_event(event)
    def update(self, dt):
        self.current_scene.update(dt)
    def render(self, screen):
        self.current_scene.render(screen)
```
# === FILE END: scene_manager.py ===
# === FILE START: settings.json ===
```json
{
  "screen_width": 1600,
  "screen_height": 900,
  "fullscreen": false,
  "audio": {
    "enabled": true,
    "master_volume": 0.8,
    "num_channels": 8,
    "sounds": {
      "pellet_drop": [
        "assets/audio/shake1.wav",
        "assets/audio/shake2.wav",
        "assets/audio/shake3.wav"
      ],
      "bite": [
        "assets/audio/bite1.wav"
      ],
      "death": [
        "assets/audio/death.wav"
      ]
    },
    "volumes": {
      "pellet_drop": 1.0,
      "bite": 1.0,
      "death": 0.70
    }
  }
}
```
# === FILE END: settings.json ===
# === FILE START: world.py ===
```python
# world.py
from __future__ import annotations
from collections import defaultdict
from typing import Any, DefaultDict, Dict, Generator, Iterable, List, Optional, Set, Tuple, Type
class World:
    # Small enum-like aliases avoid magic strings in call sites
    PHASE_UPDATE = "update"
    PHASE_RENDER = "render"
    def __init__(self) -> None:
        # Monotonic entity id source
        self._next_entity_id: int = 1
        # Per-entity component storage:
        # {entity_id: {ComponentClass: component_instance}}
        self._components: Dict[int, Dict[Type[Any], Any]] = {}
        # Creation order of entities; used to produce stable iteration order
        self.entities: List[int] = []
        # Reverse index for fast queries:
        # {ComponentClass: set(entity_id, ...)}
        self._component_index: DefaultDict[Type[Any], Set[int]] = defaultdict(set)
        # Systems are callables with `update(world, dt)`; separated by phase
        self._update_systems: List[Any] = []
        self._render_systems: List[Any] = []
    # -------------------------------------------------------------------------
    # Entity management
    # -------------------------------------------------------------------------
    def create_entity(self) -> int:
        """Create an empty entity and return its id."""
        eid = self._next_entity_id
        self._next_entity_id += 1
        self.entities.append(eid)
        self._components[eid] = {}  # empty component map
        return eid
    def destroy_entity(self, entity: int) -> None:
        """Remove an entity, all its components, and update indices."""
        comps = self._components.pop(entity, None)
        if comps:
            # Remove the entity from all component indices it participated in
            for ctype in comps:
                idx = self._component_index.get(ctype)
                if idx is not None:
                    idx.discard(entity)
                    if not idx:
                        # Keep the reverse index tidy (optional)
                        self._component_index.pop(ctype, None)
        # Remove from stable order list
        try:
            self.entities.remove(entity)
        except ValueError:
            # Already absent (defensive)
            pass
    # -------------------------------------------------------------------------
    # Component management
    # -------------------------------------------------------------------------
    def add_component(self, entity: int, component: Any) -> None:
        """Attach/replace a component and update the reverse index."""
        bucket = self._components.get(entity)
        if bucket is None:
            # Unknown entity: ignore (or raise if you prefer strictness)
            return
        ctype = type(component)
        bucket[ctype] = component
        self._component_index[ctype].add(entity)
    def remove_component(self, entity: int, component_type: Type[Any]) -> None:
        """Detach a component and update the reverse index (if present)."""
        bucket = self._components.get(entity)
        if not bucket or component_type not in bucket:
            return
        del bucket[component_type]
        idx = self._component_index.get(component_type)
        if idx is not None:
            idx.discard(entity)
            if not idx:
                self._component_index.pop(component_type, None)
    def get_component(self, entity: int, component_type: Type[Any]) -> Optional[Any]:
        """Fetch a single component; returns None if missing."""
        bucket = self._components.get(entity)
        return None if bucket is None else bucket.get(component_type)
    def has_components(self, entity: int, *component_types: Type[Any]) -> bool:
        """Quick check that an entity has all of the given components."""
        bucket = self._components.get(entity)
        if not bucket:
            return False
        return all(ct in bucket for ct in component_types)
    # -------------------------------------------------------------------------
    # Queries
    # -------------------------------------------------------------------------
    def entities_with(self, *component_types: Type[Any]) -> Generator[int, None, None]:
        """
        Yield entity ids that have all requested component types.
        Uses the reverse index to intersect sets (fast), then yields
        in entity creation order (stable updates).
        """
        if not component_types:
            # No filter — rare but supported
            yield from self.entities
            return
        # Pull the per-component index sets; short-circuit on missing/empty
        sets: List[Set[int]] = []
        get = self._component_index.get
        for ct in component_types:
            s = get(ct)
            if not s:
                return  # nothing matches at all
            sets.append(s)
        # Intersect smallest → largest for speed
        sets.sort(key=len)
        result: Set[int]
        if len(sets) == 1:
            # Single-component fast path: avoid copying into a new set
            result = sets[0]
        else:
            result = sets[0].intersection(*sets[1:])
        # Yield in deterministic creation order (important for stability)
        for eid in self.entities:
            if eid in result:
                yield eid
    # -------------------------------------------------------------------------
    # Systems
    # -------------------------------------------------------------------------
    def add_system(self, system: Any, phase: str = PHASE_UPDATE) -> None:
        """Register a system for the given phase ('update' or 'render')."""
        if phase == self.PHASE_RENDER:
            self._render_systems.append(system)
        else:
            # Default / anything else routes to update phase
            self._update_systems.append(system)
    def update(self, dt: float) -> None:
        """Run all update-phase systems."""
        for system in self._update_systems:
            system.update(self, dt)
    def render(self) -> None:
        """Run all render-phase systems (dt usually unused → pass 0.0)."""
        for system in self._render_systems:
            system.update(self, 0.0)
```
# === FILE END: world.py ===
# === FILE START: data\aging.json ===
```json
{
  "_comment": "Global aging + frailty tuning",
  "egg_threshold_ratio": 0.02,
  "juvenile_threshold_ratio": 0.15,
  "elder_threshold_ratio": 0.80,
  "egg_speed_multiplier": 0.0,
  "juvenile_speed_multiplier_min": 0.85,
  "elder_speed_multiplier_min": 0.70,
  "elder_health_decay_at_max_per_sec": 0.04,
  "_comment2": "At lifespan end: +4% of max health lost per second; scales from threshold→1",
  "hard_death_at_lifespan": true,
  "_comment_visual": "Render-time aging visuals (no new art needed)",
  "juvenile_scale": 0.5,
  "senior_desaturate": 0.6,
  "senior_tint": [235, 225, 215],
  "senior_outline": true,
  "senior_outline_color": [40, 35, 30, 255],
  "senior_outline_px": 1
}
```
# === FILE END: data\aging.json ===
# === FILE START: data\balancing.json ===
```json
{
  "movement_damping": 0.995,
  "wall_bounce": 0.30,
  "typical_max_speed": 40.0,
  "avoidance_margin": 20.0,
  "avoidance_max_strength": 0.25,
  "dead_sink_speed": 30.0,
  "state_speed_smoothing": 0.10,
  "idle_arrival_threshold": 6.0,
  "idle_bob_x_factor": 1.0,
  "idle_bob_y_factor": 0.8,
  "food_fall_speed": 60.0
}
```
# === FILE END: data\balancing.json ===
# === FILE START: data\breeding.json ===
```json
{
  "enabled": true,
  "mate_radius": 120.0,
  "pair_distance": 40.0,
  "courtship_time_sec": 1.0,
  "courtship_grace_sec": 0.3,
  "cooldown_sec": 10.0,
  "offspring_count_range": [1, 3],
  "min_health_ratio": 0.6,
  "min_hunger_ratio": 0.4,
  "max_population": 60
}
```
# === FILE END: data\breeding.json ===
# === FILE START: data\fish_defaults.json ===
```json
{
  "_comment_stats": "Global default stats for all fish.",
  "hunger_max": 100.0,
  "health_max": 100.0,
  "hunger_rate": 1.0,
  "health_regen_factor": 0.10,
  "_comment_health_regen_factor": "Percent of max health per second regained when well-fed.",
  "health_starve_factor": 0.1,
  "_comment_health_starve_factor": "Percent of max health per second lost when hunger is zero.",
  "health_regen_threshold": 0.5,
  "_comment_health_regen_threshold": "Hunger ratio above which health regenerates.",
  "speed": 100.0,
  "acceleration": 200.0,
  "turn_speed": 8,
  "dart_multiplier": 2.5,
  "_comment_behavior": "FSM behavior defaults for all fish.",
  "cruise_min_time": 6.0,
  "cruise_max_time": 16.0,
  "cruise_arrival_radius": 40.0,
  "cruise_speed_factor": 0.6,
  "transition_to_idle_chance": 0.01,
  "idle_min_time": 3.0,
  "idle_max_time": 12.0,
  "idle_speed_factor": 0.05,
  "idle_bob_amplitude": 100.0,
  "idle_bob_frequency": 1.0,
  "transition_to_cruise_chance": 0.02,
  "_comment_food": "Food seeking/chasing parameters.",
  "food_detect_radius": 250.0,
  "food_seek_threshold": 0.80,
  "look_for_food_speed_factor": 1.0,
  "chase_food_speed_factor": 1.00,
  "food_nutrition": 40.0,
  "_comment_misc": "General noise and personalization",
  "noise": 0.1,
  "mouth_radius_factor": 0.40,
  "eat_extra_margin": 8.0,
  "_comment_pellet_debug": "Pellet collision tuning. Scale multiplies sprite half-size; offsets shift the perceived center (px).",
  "pellet_radius_scale": 1.35,
  "pellet_center_offset_x": 0.0,
  "pellet_center_offset_y": 0.0
}
```
# === FILE END: data\fish_defaults.json ===
# === FILE START: data\loot_tables.json ===
```json
```
# === FILE END: data\loot_tables.json ===
# === FILE START: data\pellets.json ===
```json
{
  "_comment": "All pellet-related params live here.",
  "sprite": "pellet",
  "width": 16,
  "height": 16,
  "radius_scale": 1.35,
  "nutrition": 40.0,
  "fall_speed": 60.0
}
```
# === FILE END: data\pellets.json ===
# === FILE START: data\prices.json ===
```json
```
# === FILE END: data\prices.json ===
# === FILE START: data\species.json ===
```json
{
  "goldfish": {
    "sprite": "goldfish",
    "width": 60,
    "height": 40,
    "max_age": 300,
    "speed": 100.0,
    "acceleration": 200.0,
    "turn_speed": 8,
    "behavior": {}
  },
  "betta": {
    "sprite": "betta",
    "width": 64,
    "height": 40,
    "max_age": 300,
    "speed": 85.0,
    "acceleration": 170.0,
    "turn_speed": 10,
    "behavior": {
      "idle_bob_amplitude": 70.0
    }
  },
  "corydoras": {
    "sprite": "corydoras",
    "width": 54,
    "height": 28,
    "max_age": 10,
    "speed": 90.0,
    "acceleration": 180.0,
    "turn_speed": 9,
    "behavior": {}
  },
  "guppy": {
    "sprite": "guppy",
    "width": 36,
    "height": 20,
    "max_age": 300,
    "speed": 120.0,
    "acceleration": 220.0,
    "turn_speed": 12,
    "behavior": {}
  },
  "neontetra": {
    "sprite": "neontetra",
    "width": 32,
    "height": 18,
    "max_age": 300,
    "speed": 135.0,
    "acceleration": 230.0,
    "turn_speed": 14,
    "behavior": {}
  }
}
```
# === FILE END: data\species.json ===
# === FILE START: data\tank_defaults.json ===
```json
{
  "logical_tank_width": 1200,
  "logical_tank_height": 700,
  "default_background": "tank_bg",
  "min_wall_offset": 20,
  "sand_top_ratio": 0.78,
  "swim_bottom_margin": 80
}
```
# === FILE END: data\tank_defaults.json ===
# === FILE START: data\ui_config.json ===
```json
{
  "comment": "UI and rendering config. Comments live in 'comment*' keys.",
  "render_cache_limit": 256,
  "ui_font_size": 14,
  "ui_bar_height": 4,
  "ui_bar_gap": 6,
  "ui_label_offset": 2,
  "ui_target_line_width": 1,
  "ui_velocity_arrow_scale": 0.5,
  "ui_avoidance_arrow_scale": 40.0,
  "ui_debug_border_width": 1,
  "comment_ui": "Cache size for scaled sprites; font size; bar sizes/gaps; label offset; debug line widths and vector scales.",
  "ui_tank_label_size": 32,
  "ui_tank_label_color": [255, 255, 255],
  "ui_tank_label_shadow": true,
  "ui_tank_label_bottom_margin": 28,
  "ui_toolbar_button_size": 48,
  "ui_toolbar_margin_x": 12,
  "ui_toolbar_margin_y": 12
}
```
# === FILE END: data\ui_config.json ===
# === FILE START: ecs\__init__.py ===
```python
```
# === FILE END: ecs\__init__.py ===
# === FILE START: render\__init__.py ===
```python
```
# === FILE END: render\__init__.py ===
# === FILE START: render\asset_manager.py ===
```python
# [render/asset_manager.py] — tolerate missing folders & bad images, optional logging
import pygame, os
class AssetManager:
    def __init__(self):
        self.images = {}
    def load_folder(self, folder_path, scale=1.0, colorkey=None):
        if not os.path.isdir(folder_path):
            print(f"⚠ Assets folder missing: {folder_path}")
            return
        for filename in os.listdir(folder_path):
            if not filename.lower().endswith((".png", ".jpg", ".jpeg")):
                continue
            key = os.path.splitext(filename)[0]
            path = os.path.join(folder_path, filename)
            try:
                img = pygame.image.load(path).convert_alpha()
            except Exception as exc:
                print(f"⚠ Failed to load image '{path}': {exc}")
                continue
            if colorkey is not None:
                img.set_colorkey(colorkey)
            if scale != 1.0:
                img = pygame.transform.smoothscale(
                    img, (int(img.get_width()*scale), int(img.get_height()*scale))
                )
            self.images[key] = img
    def get(self, key):
        return self.images.get(key)
```
# === FILE END: render\asset_manager.py ===
# === FILE START: render\audio_manager.py ===
```python
# render/audio_manager.py
import os
import random
import pygame
from typing import Dict, List, Optional
class AudioManager:
    """
    Minimal, settings-driven SFX manager.
    Settings structure (in settings.json):
    {
      "audio": {
        "enabled": true,
        "master_volume": 0.8,
        "num_channels": 8,
        "sounds": {
          "pellet_drop": ["assets/audio/shake1.wav", "assets/audio/shake2.wav", "assets/audio/shake3.wav"],
          "ui_click": ["assets/audio/click1.wav", "assets/audio/click2.wav"]
        },
        "volumes": {
          "pellet_drop": 1.0,     // optional per-sound volume multiplier
          "ui_click": 0.6
        }
      }
    }
    Usage:
        audio.play("pellet_drop")
        audio.play("ui_click", volume=0.4)
    """
    def __init__(self, settings: dict):
        self._settings = settings or {}
        a = (self._settings.get("audio") or {})
        self.enabled       = bool(a.get("enabled", True))
        self.master_volume = float(a.get("master_volume", 0.8))
        self.num_channels  = int(a.get("num_channels", 8))
        # sounds: name -> list[file paths]
        self._bank_files: Dict[str, List[str]] = dict(a.get("sounds") or {})
        # per-sound volume multipliers (optional)
        self._volumes: Dict[str, float] = {k: float(v) for k, v in (a.get("volumes") or {}).items()}
        self._bank: Dict[str, List[pygame.mixer.Sound]] = {}
        self._ready = False
        self._init_mixer()
        self._load_bank()
    # -------- internal ----------
    def _init_mixer(self):
        if not self.enabled:
            return
        try:
            if not pygame.mixer.get_init():
                pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=512)
            pygame.mixer.set_num_channels(self.num_channels)
            self._ready = True
        except Exception as exc:
            print(f"⚠ Audio disabled (mixer init failed): {exc}")
            self.enabled = False
            self._ready = False
    def _load_bank(self):
        if not (self.enabled and self._ready):
            return
        for name, files in self._bank_files.items():
            sounds: List[pygame.mixer.Sound] = []
            for path in files:
                try:
                    if not os.path.isfile(path):
                        print(f"⚠ Missing audio file: {path}")
                        continue
                    s = pygame.mixer.Sound(path)
                    sounds.append(s)
                except Exception as exc:
                    print(f"⚠ Failed to load sound '{path}': {exc}")
            if not sounds:
                print(f"⚠ No audio clips loaded for '{name}'")
            self._bank[name] = sounds
    def _resolve_volume(self, name: str, volume: Optional[float]) -> float:
        # final = master * per-sound * call-time
        per_sound = float(self._volumes.get(name, 1.0))
        call = 1.0 if volume is None else float(volume)
        return max(0.0, min(1.0, self.master_volume * per_sound * call))
    # -------- public API ----------
    def play(self, name: str, *, volume: Optional[float] = None):
        """Play a random clip from the named sound bank (if available)."""
        if not (self.enabled and self._ready):
            return
        clips = self._bank.get(name)
        if not clips:
            # Silent fail is fine in games; keep logs minimal
            # print(f"⚠ Sound '{name}' not found or empty.")
            return
        clip = random.choice(clips)
        try:
            clip.set_volume(self._resolve_volume(name, volume))
            clip.play()
        except Exception as exc:
            print(f"⚠ Failed to play '{name}': {exc}")
    # Backwards-compat alias for any existing calls
    def play_shake(self):
        self.play("pellet_drop")
```
# === FILE END: render\audio_manager.py ===
# === FILE START: render\renderer.py ===
```python
```
# === FILE END: render\renderer.py ===
# === FILE START: saves\__init__.py ===
```python
```
# === FILE END: saves\__init__.py ===
# === FILE START: scenes\__init__.py ===
```python
```
# === FILE END: scenes\__init__.py ===
# === FILE START: scenes\base_scene.py ===
```python
class BaseScene:
    def handle_event(self, event):
        pass
    def update(self, dt: float):
        pass
    def render(self, screen):
        pass
```
# === FILE END: scenes\base_scene.py ===
# === FILE START: scenes\tank_scene.py ===
```python
# scenes/tank_scene.py
import random
import pygame
from scenes.base_scene import BaseScene
from world import World
# Core/tank
from ecs.components.core.position_component import Position
from ecs.components.core.bounds_component import Bounds
from ecs.components.core.tank_style_component import TankStyle
from ecs.components.core.tank_label_component import TankLabel
from ecs.components.core.tank_component import Tank
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.core.sprite_component import Sprite
# Fish core
from ecs.components.fish.species_component import Species
from ecs.components.fish.age_component import Age
from ecs.components.fish.health_component import Health
from ecs.components.fish.hunger_component import Hunger
from ecs.components.fish.breeding_component import Breeding
# Motion/AI (needed for movement)
from ecs.components.core.velocity_component import Velocity
from ecs.components.fish.motion_component import MotionParams
from ecs.components.fish.target_intent_component import TargetIntent
from ecs.components.fish.steering_intent_component import SteeringIntent
from ecs.components.fish.speed_intent_component import SpeedIntent
from ecs.components.fish.brain_component import Brain
from ecs.components.fish.behavior_tuning import BehaviorTuning
# Input/UI
from ecs.systems.ui.input_router import InputRouter
from ecs.systems.ui.keyboard_system import KeyboardSystem
from ecs.systems.ui.mouse_system import MouseSystem
from ecs.systems.ui.placement_system import PlacementSystem
# Update systems
from ecs.systems.core.resize_system import ResizeSystem
from ecs.systems.core.movement_system import MovementSystem
from ecs.systems.core.collision_system import CollisionSystem
from ecs.systems.core.avoidance_system import AvoidanceSystem
from ecs.systems.physics.gravity_system import GravitySystem
from ecs.systems.gameplay.hunger_system import HungerSystem
from ecs.systems.gameplay.health_system import HealthSystem
from ecs.systems.gameplay.aging_system import AgingSystem
# Rendering
from ecs.systems.rendering.tank_render_system import TankRenderSystem
from ecs.systems.rendering.sprite_render_system import SpriteRenderSystem
from ecs.systems.rendering.fish_overlay_system import FishOverlaySystem
from ecs.systems.ui.debug.debug_overlay_system import DebugOverlaySystem
from ecs.systems.ui.debug.debug_menu import DebugMenu
from ecs.systems.ui.ui_toolbar_system import UIToolbarSystem
from ecs.systems.ui.cursor_system import CursorSystem
from ecs.systems.ui.fish_window_system import FishWindowSystem
from ecs.systems.ui.fish_inspector_system import FishInspectorSystem
from ecs.systems.ui.widgets.panel_manager_system import PanelManagerSystem
# AI
from ecs.systems.ai.behavior_system import BehaviorSystem
from ecs.systems.ai.state_override_system import StateOverrideSystem
from ecs.systems.ai.state_transition_system import StateTransitionSystem
# Breeding
from ecs.systems.gameplay.population_guard import PopulationGuard
# Factories
from ecs.factories.fish_factory import create_fish
class TankScene(BaseScene):
    """
    Scene wiring:
      - Events → InputRouter → (KeyboardSystem / MouseSystem)
      - PlacementSystem spawns pellets/eggs each update
      - Breeding: PopulationGuard → Eligibility → MateSearch → Courtship
      - AI: Behavior → Override → Transition (then movement/collision)
    """
    def __init__(self, context, screen):
        super().__init__()
        self.context = context
        self.screen = screen
        self.world = World()
        # ---------- Input ----------
        self.keyboard = KeyboardSystem(context)
        self.mouse = MouseSystem(context, screen, context.assets)
        self.placement = PlacementSystem(context)
        self.input_router = InputRouter(self.keyboard, self.mouse)
        self.mouse.set_placement(self.placement)
        self.context.spawn_egg = self.placement.spawn_egg_at
        # ---------- Systems (order matters) ----------
        self.world.add_system(ResizeSystem(context), phase="update")
        # Gameplay basics
        self.world.add_system(HungerSystem(), phase="update")
        self.world.add_system(HealthSystem(), phase="update")
        self.world.add_system(AgingSystem(context), phase="update")
        # Breeding loop
        self.population_guard = PopulationGuard(context)
        self.world.add_system(self.population_guard, phase="update")
        # AI “sandwich” (Behavior is driven outside world.update to pass planned states)
        self.behavior = BehaviorSystem(context)
        self.override = StateOverrideSystem()
        self.transition = StateTransitionSystem(context, self.behavior)
        # Motion & physics
        self.world.add_system(AvoidanceSystem(context), phase="update")
        self.world.add_system(MovementSystem(context), phase="update")
        self.world.add_system(CollisionSystem(context), phase="update")
        self.world.add_system(GravitySystem(context), phase="update")
        # Spawners late
        self.world.add_system(self.placement, phase="update")
        # Rendering
        self.tank_renderer = TankRenderSystem(screen, context.assets, context)
        self.sprite_renderer = SpriteRenderSystem(screen, context.assets, context)
        self.fish_overlay = FishOverlaySystem(screen, context.assets, context)
        self.debug_overlay = DebugOverlaySystem(screen, context)
        self.ui_toolbar = UIToolbarSystem(screen, context.assets, context)
        self.cursor_system = CursorSystem(screen, context.assets, context)
        self.fish_window = FishWindowSystem(screen, context.assets, context)
        self.fish_inspector = FishInspectorSystem(screen, context.assets, context)
        self.panel_manager = PanelManagerSystem(screen, context.assets, context)
        self.world.add_system(self.tank_renderer, phase="render")
        self.world.add_system(self.sprite_renderer, phase="render")
        self.world.add_system(self.fish_overlay, phase="render")
        self.world.add_system(self.debug_overlay, phase="render")
        self.world.add_system(DebugMenu(screen, context), phase="render")
        self.world.add_system(self.ui_toolbar, phase="render")
        self.world.add_system(self.cursor_system, phase="render")
        self.world.add_system(self.fish_window, phase="render")
        self.world.add_system(self.fish_inspector, phase="render")
        self.world.add_system(self.panel_manager, phase="render")
        # ---------- Tank ----------
        tank = self.world.create_entity()
        self.tank_entity = tank
        self.world.add_component(tank, Tank())
        self.world.add_component(tank, Position(0, 0))
        self.world.add_component(tank, Bounds(1, 1))
        self.world.add_component(tank, TankStyle())
        self.world.add_component(tank, TankLabel(text="My Tank"))
        self.keyboard.set_tank(tank)
        self.mouse.set_tank(tank)
        self.mouse.set_panel_manager(self.panel_manager)
        self.mouse.set_world_ref(self.world)
        self.placement.set_tank(tank)
        self.tank_entity = tank
        # Spawn from config
        for sid, data in (self.context.species_config or {}).items():
            x = random.uniform(0, self.context.logical_tank_w)
            y = random.uniform(0, self.context.logical_tank_h)
            create_fish(self.world, self.context, tank, sid, data, x, y)
        # EXTRA: adults for breeding + movement debug
        self._spawn_debug_adults(tank)
        # Initial resize once
        if not self.context.needs_resize:
            sw, sh = self.screen.get_size()
            self.context.new_screen_w = sw
            self.context.new_screen_h = sh
            self.context.needs_resize = True
        self.world.update(0.0)
    # ---------- Scene API ----------
    def handle_event(self, event):
        self.input_router.handle_event(event)
        if event.type == pygame.VIDEORESIZE:
            self.context.new_screen_w = int(event.w)
            self.context.new_screen_h = int(event.h)
            self.context.needs_resize = True
    def update(self, dt):
        # Drive AI pipeline around world.update so intents are fresh
        proposed = self.behavior.update(self.world, dt)
        overridden = self.override.update(self.world, proposed)
        self.transition.update(self.world, overridden, dt)
        # Wire world ref for keyboard ops
        self.keyboard.set_world_ref(self.world)
        self.keyboard.update(self.world, dt)
        self.mouse.update(self.world, dt)
        self.world.update(dt)
    def render(self, screen):
        self.world.render()
    def set_screen(self, new_screen):
        self.screen = new_screen
        self.mouse.screen = new_screen
        self.tank_renderer.screen = new_screen
        self.sprite_renderer.screen = new_screen
        self.fish_overlay.screen = new_screen
        self.debug_overlay.screen = new_screen
        self.ui_toolbar.screen = new_screen
        self.fish_inspector.screen = new_screen
        self.panel_manager.screen = new_screen
    # ---------- Helpers ----------
    def _spawn_debug_adults(self, tank):
        """Adult fish with full movement + AI + breeding toggle_on."""
        cfg = self.context.species_config.get("goldfish", {"sprite": "goldfish", "width": 60, "height": 40})
        W = float(self.context.logical_tank_w)
        H = float(self.context.logical_tank_h)
        def rand_target():
            margin = 40
            return (
                random.uniform(margin, max(margin, W - margin)),
                random.uniform(margin, max(margin, H - margin)),
            )
        for i in range(6):
            x = (i % 3) * (W / 3.5) + 80
            y = (i // 3) * (H / 3.0) + 120
            tx, ty = rand_target()
            e = self.world.create_entity()
            self.world.add_component(e, TankRef(tank))
            self.world.add_component(e, Position(x, y))
            self.world.add_component(e, Sprite(cfg.get("sprite", "goldfish"), cfg.get("width", 60), cfg.get("height", 40)))
            self.world.add_component(e, Species("goldfish", "Goldfish", base_speed=150.0))
            # Movement + AI essentials (missing before → fish were static)
            self.world.add_component(e, Velocity(0.0, 0.0))
            self.world.add_component(e, MotionParams(max_speed=150.0, acceleration=220.0, turn_speed=8.0))
            self.world.add_component(e, TargetIntent(tx, ty))
            self.world.add_component(e, SpeedIntent(0.0))
            self.world.add_component(e, SteeringIntent())
            self.world.add_component(e, Brain(state="Cruise"))
            self.world.add_component(e, BehaviorTuning({
                "cruise_min_time": 1.0,
                "cruise_max_time": 2.0,
                "cruise_arrival_radius": 40.0,
                "cruise_speed_factor": 0.6,
                "transition_to_idle_chance": 0.05,
                "idle_min_time": 0.6,
                "idle_max_time": 1.4,
                "idle_speed_factor": 0.08,
                "idle_bob_amplitude": 18.0,
                "idle_bob_frequency": 0.8,
                "transition_to_cruise_chance": 0.25,
                "food_detect_radius": 250.0,
                "food_seek_threshold": 0.80,
                "look_for_food_speed_factor": 1.0,
                "chase_food_speed_factor": 1.00,
                "food_nutrition": 40.0,
                "noise": 0.05,
                "mouth_radius_factor": 0.40,
                "eat_extra_margin": 8.0,
            }))
            # Life state + breeding
            self.world.add_component(e, Age(age=0.0, lifespan=200.0, stage="Adult"))
            self.world.add_component(e, Health(value=100.0, max_value=100.0))
            self.world.add_component(e, Hunger(hunger=100.0, hunger_rate=0.1, hunger_max=100.0))
            self.world.add_component(e, Breeding(toggle_on=True))
```
# === FILE END: scenes\tank_scene.py ===
# === FILE START: tests\__init__.py ===
```python
```
# === FILE END: tests\__init__.py ===
# === FILE START: tests\conftest.py ===
```python
# tests/conftest.py
# pytest shared fixtures: headless pygame, deterministic RNG, and handy builders.
import os
import random
import pytest
# Headless drivers must be set before importing pygame
os.environ.setdefault("SDL_VIDEODRIVER", "dummy")
os.environ.setdefault("SDL_AUDIODRIVER", "dummy")
import pygame
from world import World
from game_context import GameContext
# Core components we’ll reuse in fixtures
from ecs.components.core.position_component import Position
from ecs.components.core.bounds_component import Bounds
from ecs.components.core.tank_component import Tank
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.velocity_component import Velocity
from ecs.components.fish.motion_component import MotionParams
from ecs.components.fish.target_intent_component import TargetIntent
from ecs.components.fish.steering_intent_component import SteeringIntent
from ecs.components.fish.speed_intent_component import SpeedIntent
from ecs.components.fish.brain_component import Brain
from ecs.components.fish.behavior_tuning import BehaviorTuning
from ecs.components.fish.species_component import Species
from ecs.components.fish.age_component import Age
from ecs.components.fish.hunger_component import Hunger
from ecs.components.fish.health_component import Health
@pytest.fixture(scope="session", autouse=True)
def _pygame_bootstrap():
    """Initialize pygame + font + a tiny video mode once for the whole suite."""
    pygame.init()                 # includes font.init()
    pygame.font.init()
    pygame.display.init()
    pygame.display.set_mode((1, 1))
    try:
        yield
    finally:
        # single, orderly shutdown at end of session
        pygame.display.quit()
        pygame.font.quit()
        pygame.quit()
@pytest.fixture(autouse=True)
def _deterministic_random_seed():
    random.seed(1337)
@pytest.fixture
def dt():
    return 0.016  # ~60 FPS
@pytest.fixture
def make_context():
    """Construct a GameContext and allow overrides for logical tank sizing, etc."""
    def _mk(**overrides):
        ctx = GameContext()
        if "logical_w" in overrides:
            ctx.logical_tank_w = int(overrides["logical_w"])
        if "logical_h" in overrides:
            ctx.logical_tank_h = int(overrides["logical_h"])
        for k, v in overrides.items():
            setattr(ctx, k, v)
        return ctx
    return _mk
@pytest.fixture
def make_world():
    return lambda: World()
@pytest.fixture
def make_tank():
    def _mk(world, x=0, y=0, w=600, h=400):
        e = world.create_entity()
        world.add_component(e, Tank())
        world.add_component(e, Position(x, y))
        world.add_component(e, Bounds(w, h))
        return e
    return _mk
@pytest.fixture
def make_dummy_fish(make_tank):
    """
    Create a fish entity with the components your systems expect.
    Adds a TankRef so render/behavior math that needs a tank still works.
    """
    def _mk(world, x=100, y=200, max_speed=150.0, species="goldfish"):
        tank = make_tank(world, x=0, y=0, w=800, h=600)
        e = world.create_entity()
        world.add_component(e, TankRef(tank))
        world.add_component(e, Position(x, y))
        world.add_component(e, Sprite(image_id=species, base_w=60, base_h=40))
        world.add_component(e, Velocity(0.0, 0.0))
        world.add_component(e, MotionParams(max_speed=max_speed, acceleration=200.0, turn_speed=8.0))
        world.add_component(e, TargetIntent(x, y))
        world.add_component(e, SpeedIntent(0.0))
        world.add_component(e, SteeringIntent())
        world.add_component(e, Brain(state="Cruise"))
        world.add_component(e, BehaviorTuning({
            "cruise_min_time": 0.2,
            "cruise_max_time": 0.3,
            "cruise_arrival_radius": 40.0,
            "cruise_speed_factor": 0.6,
            "transition_to_idle_chance": 0.0,
            "idle_min_time": 0.1,
            "idle_max_time": 0.2,
            "idle_speed_factor": 0.05,
            "idle_bob_amplitude": 20.0,
            "idle_bob_frequency": 1.0,
            "transition_to_cruise_chance": 0.02,
            "food_detect_radius": 250.0,
            "food_seek_threshold": 0.80,
            "look_for_food_speed_factor": 1.0,
            "chase_food_speed_factor": 1.00,
            "food_nutrition": 40.0,
            "noise": 0.0,
            "mouth_radius_factor": 0.40,
            "eat_extra_margin": 8.0,
        }))
        world.add_component(e, Species(species_id=species, display_name=species.title(), base_speed=max_speed))
        world.add_component(e, Age(age=0.0, lifespan=5.0, stage="Adult", pre_hatch=0.0))
        world.add_component(e, Hunger(hunger=50.0, hunger_rate=1.0, hunger_max=100.0))
        world.add_component(e, Health(value=100.0, max_value=100.0))
        return e
    return _mk
```
# === FILE END: tests\conftest.py ===
# === FILE START: tests\helpers.py ===
```python
# tests/helpers.py
from world import World
from game_context import GameContext
def make_world():
    return World()
def make_context(**overrides):
    ctx = GameContext()
    # keep parity with your conftest defaults
    if "logical_w" in overrides:
        ctx.logical_tank_w = int(overrides["logical_w"])
    if "logical_h" in overrides:
        ctx.logical_tank_h = int(overrides["logical_h"])
    for k, v in overrides.items():
        setattr(ctx, k, v)
    return ctx
```
# === FILE END: tests\helpers.py ===
# === FILE START: tests\test_age_health.py ===
```python
from world import World
from game_context import GameContext
from ecs.components.core.position_component import Position
from ecs.components.core.sprite_component import Sprite
from ecs.components.fish.age_component import Age
from ecs.components.fish.hunger_component import Hunger
from ecs.components.fish.health_component import Health
from ecs.components.fish.behavior_tuning import BehaviorTuning
from ecs.systems.gameplay.hunger_system import HungerSystem
from ecs.systems.gameplay.health_system import HealthSystem
from ecs.systems.gameplay.aging_system import AgingSystem
def _fish_with_age(world: World):
    e = world.create_entity()
    world.add_component(e, Age(stage="Egg", age=0.0))
    world.add_component(e, Hunger(hunger=0.0, hunger_rate=0.0, hunger_max=100.0))
    world.add_component(e, Health(value=100.0, max_value=100.0))
    world.add_component(e, Position(0.0, 0.0))
    world.add_component(e, Sprite("goldfish", 60, 40))
    # HealthSystem in this build reads regen/starve from BehaviorTuning
    world.add_component(
        e,
        BehaviorTuning(
            {
                "health_regen_factor": 0.0,
                "health_regen_threshold": 1.0,
                "health_starve_factor": 0.5,
            }
        ),
    )
    return e
def test_egg_hatches_then_juvenile_defaults(make_context, dt):
    """Sanity check: egg ages through hatch without crashing."""
    world = World()
    ctx: GameContext = make_context()
    fish = _fish_with_age(world)
    age_sys = AgingSystem(ctx)
    hunger_sys = HungerSystem()
    health_sys = HealthSystem()
    # Run a few steps to ensure no exceptions and state evolves
    for _ in range(10):
        age_sys.update(world, dt)
        hunger_sys.update(world, dt)
        health_sys.update(world, dt)
    age = world.get_component(fish, Age)
    assert age is not None
    assert age.age >= 0.0  # progressed in time
def test_starvation_then_health_decay(make_context, dt):
    world = World()
    ctx: GameContext = make_context()
    fish = _fish_with_age(world)
    # make it post-hatch and then starve it
    age = world.get_component(fish, Age)
    age.stage = "Adult"
    age.age = 0.0
    hunger = world.get_component(fish, Hunger)
    hunger.hunger = 1.0
    hunger.hunger_rate = 10.0  # hit zero quickly
    health = world.get_component(fish, Health)
    h0 = health.value
    hunger_sys = HungerSystem()
    health_sys = HealthSystem()
    # Step until hunger bottoms and health starts decaying
    for _ in range(30):
        hunger_sys.update(world, dt)
        health_sys.update(world, dt)
    assert world.get_component(fish, Hunger).hunger <= 0.0
    assert world.get_component(fish, Health).value < h0  # should decay under starvation
```
# === FILE END: tests\test_age_health.py ===
# === FILE START: tests\test_collision_avoidance.py ===
```python
import math
from world import World
from game_context import GameContext
from ecs.components.core.position_component import Position
from ecs.components.core.velocity_component import Velocity
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.tank_ref_component import TankRef
from ecs.systems.core.avoidance_system import AvoidanceSystem
from ecs.components.fish.steering_intent_component import SteeringIntent
def _add_tank(world: World, w: int, h: int):
    e = world.create_entity()
    # Many systems just need TankRef to exist on entities plus logical size in context.
    return e
def _make_fish_at(world: World, tank, x, y, w=40, h=20):
    e = world.create_entity()
    world.add_component(e, TankRef(tank))
    world.add_component(e, Position(x, y))
    world.add_component(e, Sprite("goldfish", w, h))
    world.add_component(e, Velocity(0.0, 0.0))
    # AvoidanceSystem writes into SteeringIntent; ensure it exists
    world.add_component(e, SteeringIntent())
    return e
def test_wall_bounce_and_clamp(make_context):
    world = World()
    ctx: GameContext = make_context(logical_w=200, logical_h=100)
    ctx.logical_tank_w = 200
    ctx.logical_tank_h = 100
    tank = _add_tank(world, 200, 100)
    fish = _make_fish_at(world, tank, x=1, y=50, w=10, h=10)
    vel = world.get_component(fish, Velocity)
    vel.vx = -30.0  # aiming out of bounds
    sys = AvoidanceSystem(ctx)
    # Single update should push intent to the right
    sys.update(world, dt=0.016)
    intent = world.get_component(fish, SteeringIntent)
    assert intent.dx >= 0.0  # bounced / clamped to non-left
def test_avoidance_pushes_away_from_wall(make_context):
    world = World()
    ctx: GameContext = make_context(logical_w=200, logical_h=100)
    ctx.logical_tank_w = 200
    ctx.logical_tank_h = 100
    tank = _add_tank(world, 200, 100)
    fish = _make_fish_at(world, tank, x=5, y=50, w=10, h=10)
    pos0 = world.get_component(fish, Position).x
    # give it some left-ward velocity so avoidance has something to scale with
    vel = world.get_component(fish, Velocity)
    vel.vx = -20.0
    vel.vy = 0.0
    sys = AvoidanceSystem(ctx)
    for _ in range(15):
        sys.update(world, dt=0.016)
        # Movement system would normally integrate; nudge position manually so we can observe change
        intent = world.get_component(fish, SteeringIntent)
        world.get_component(fish, Position).x += max(0.0, intent.dx) * 2.0  # crude push right
    assert world.get_component(fish, Position).x > pos0
```
# === FILE END: tests\test_collision_avoidance.py ===
# === FILE START: tests\test_config_loader.py ===
```python
# Config loader tolerates missing/invalid values and normalizes types.
from config import load_config
def test_config_loader_defaults_and_normalization():
    cfg = load_config()
    # basic shape & types
    assert isinstance(cfg["screen_width"], int)
    assert isinstance(cfg["screen_height"], int)
    assert isinstance(cfg["fullscreen"], bool)
    audio = cfg.get("audio") or {}
    assert isinstance(audio.get("enabled", True), bool)
    assert 0.0 <= float(audio.get("master_volume", 0.8)) <= 1.0
    assert isinstance(audio.get("num_channels", 8), int)
    # dicts coerced
    assert isinstance(audio.get("sounds", {}), dict)
    assert isinstance(audio.get("volumes", {}), dict)
```
# === FILE END: tests\test_config_loader.py ===
# === FILE START: tests\test_fish_window_thumbs.py ===
```python
# tests/test_fish_window_thumbs.py
import os
os.environ.setdefault("SDL_AUDIODRIVER", "dummy")
os.environ.setdefault("SDL_VIDEODRIVER", "dummy")
import pygame
import pytest
from world import World
from game_context import GameContext
from ecs.components.core.position_component import Position
from ecs.components.core.bounds_component import Bounds
from ecs.components.core.tank_component import Tank
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.core.sprite_component import Sprite
from ecs.components.fish.age_component import Age
from ecs.components.fish.brain_component import Brain
from ecs.components.fish.species_component import Species
from ecs.components.fish.hunger_component import Hunger
from ecs.components.fish.health_component import Health
from ecs.systems.rendering.sprite_render_system import SpriteRenderSystem
from ecs.systems.ui.fish_window_system import FishWindowSystem
from ecs.systems.renderers.cache import SpriteCache
# ---------------------------------------------------------------------------
# Pygame bootstrap
# ---------------------------------------------------------------------------
@pytest.fixture(scope="module", autouse=True)
def _pygame_boot():
    pygame.init()
    try:
        pygame.display.set_mode((1, 1))
        yield
    finally:
        pygame.quit()
# ---------------------------------------------------------------------------
# Minimal assets - deterministic base sprites
# ---------------------------------------------------------------------------
class _Assets:
    def __init__(self):
        self.images = {}
        self.images["goldfish"] = pygame.Surface((60, 40), pygame.SRCALPHA)
        # distinct vivid color
        self.images["goldfish"].fill((100, 160, 255, 255))
    def get(self, key):
        return self.images.get(key)
# ---------------------------------------------------------------------------
# Builders
# ---------------------------------------------------------------------------
def _tank(world):
    t = world.create_entity()
    world.add_component(t, Tank())
    world.add_component(t, Position(50.0, 50.0))
    world.add_component(t, Bounds(400, 300))
    return t
def _fish(world, tank, stage="Adult", brain="Cruise"):
    e = world.create_entity()
    world.add_component(e, TankRef(tank))
    world.add_component(e, Position(120.0, 120.0))
    world.add_component(e, Sprite("goldfish", 60, 40))
    world.add_component(e, Age(age=0.0, lifespan=100.0, stage=stage, pre_hatch=0.0))
    world.add_component(e, Brain(state=brain))
    # IMPORTANT: include these so FishWindow lists the fish as a card
    world.add_component(e, Species(species_id="goldfish", display_name="Goldfish", base_speed=150.0))
    world.add_component(e, Hunger(hunger=50.0, hunger_rate=1.0, hunger_max=100.0))
    world.add_component(e, Health(value=100.0, max_value=100.0))
    return e
def _make_ctx_assets_screen():
    ctx = GameContext()
    ctx.assets = _Assets()
    screen = pygame.display.set_mode((800, 600))
    return ctx, screen
# ---------------------------------------------------------------------------
# Helpers to render and inspect the scaling used for the thumbnail
# ---------------------------------------------------------------------------
def _draw_fish_window(ctx, screen, world):
    ctx.show_fish_window = True
    win = FishWindowSystem(screen, ctx.assets, ctx)
    win.update(world, dt=0.016)
    pygame.display.flip()
    return win
class _ScaleCapture:
    """
    Wrap pygame.transform.smoothscale to capture (w,h) and detect if the
    *source* surface appears grayscale (r≈g≈b at a sample).
    """
    def __init__(self):
        self.calls = []  # list of dicts with 'size':(w,h), 'src_grey':bool
    def _looks_grey(self, surf: pygame.Surface) -> bool:
        # sample a few pixels; treat equal RGB as grayscale
        w, h = surf.get_size()
        pts = [(w//2, h//2), (1, 1), (w-2 if w>2 else 0, h-2 if h>2 else 0)]
        for x, y in pts:
            r, g, b, a = surf.get_at((x, y))
            if a > 0 and (r != g or g != b):
                return False
        return True
    def wrap(self, orig):
        def _wrapped(src, size):
            w, h = size
            src_grey = self._looks_grey(src)
            self.calls.append({"size": (int(w), int(h)), "src_grey": src_grey})
            # return a plain surface of the requested size (content not used)
            out = pygame.Surface((int(w), int(h)), pygame.SRCALPHA)
            out.fill((200, 200, 200, 255) if src_grey else (10, 200, 10, 255))
            return out
        return _wrapped
def _wrap_spritecache_get_for_capture():
    """Return (calls, wrapper) where calls.first captures the first get() usage."""
    class _Calls:
        def __init__(self):
            self.first = None
            self.all = []
        def record_first(self, **kwargs):
            if self.first is None:
                self.first = kwargs.copy()
            self.all.append(kwargs.copy())
    calls = _Calls()
    original_get = SpriteCache.shared().get
    def wrapped_get(img, w, h, *, dead=False, hflip=False, variant="normal", senior_style=None):
        calls.record_first(
            w=int(w), h=int(h),
            dead=bool(dead), hflip=bool(hflip),
            variant=variant,
            senior_style=senior_style,
            src_size=(img.get_width(), img.get_height()) if isinstance(img, pygame.Surface) else None,
        )
        return original_get(img, w, h, dead=dead, hflip=hflip, variant=variant, senior_style=senior_style)
    return calls, wrapped_get
# ---------------------------------------------------------------------------
# Tests
# ---------------------------------------------------------------------------
def test_card_adult_is_full_size_and_centered(monkeypatch):
    world = World()
    ctx, screen = _make_ctx_assets_screen()
    tank = _tank(world)
    _fish(world, tank, stage="Adult", brain="Cruise")
    cap = _ScaleCapture()
    monkeypatch.setattr(pygame.transform, "smoothscale", cap.wrap(pygame.transform.smoothscale))
    _draw_fish_window(ctx, screen, world)
    # Expect a scale call for the card thumbnail
    assert cap.calls, "no scaling calls captured for adult thumbnail"
    # Use the first scale call—thumbnail creation
    (w, h) = cap.calls[0]["size"]
    # Base: 60x40 into 72x72 box ⇒ 72x48
    assert (w, h) == (72, 48), f"adult thumb size wrong: got {(w,h)} expected (72,48)"
    # Not grayscale
    assert cap.calls[0]["src_grey"] is False, "adult should not be grayscale"
def test_card_juvenile_is_half_size_and_centered(monkeypatch):
    world = World()
    ctx, screen = _make_ctx_assets_screen()
    tank = _tank(world)
    _fish(world, tank, stage="Juvenile", brain="Cruise")
    cap = _ScaleCapture()
    monkeypatch.setattr(pygame.transform, "smoothscale", cap.wrap(pygame.transform.smoothscale))
    _draw_fish_window(ctx, screen, world)
    assert cap.calls, "no scaling calls captured for juvenile thumbnail"
    (w, h) = cap.calls[0]["size"]
    # Juvenile box: 36x36 ⇒ base 60x40 → 36x24
    assert (w, h) == (36, 24), f"juvenile thumb size wrong: got {(w,h)} expected (36,24)"
    assert cap.calls[0]["src_grey"] is False
def test_card_dead_uses_dead_variant_and_size(monkeypatch):
    world = World()
    ctx, screen = _make_ctx_assets_screen()
    tank = _tank(world)
    _fish(world, tank, stage="Adult", brain="Dead")
    # Publish finals (okay either way; card thumbs use base+variant, but harmless)
    SpriteRenderSystem(screen, ctx.assets, ctx).update(world, dt=0.016)
    # Capture the exact arguments FishWindow uses for the thumbnail build
    captured = {}
    original_get = SpriteCache.shared().get
    def wrapped_get(img, w, h, *, dead=False, hflip=False, variant="normal", senior_style=None):
        # record first call only (first card)
        if not captured:
            captured.update(dict(w=int(w), h=int(h), dead=bool(dead), hflip=bool(hflip), variant=variant))
        return original_get(img, w, h, dead=dead, hflip=hflip, variant=variant, senior_style=senior_style)
    monkeypatch.setattr(SpriteCache.shared(), "get", wrapped_get)
    # Also keep scaling capture to ensure the size path runs
    cap = _ScaleCapture()
    monkeypatch.setattr(pygame.transform, "smoothscale", cap.wrap(pygame.transform.smoothscale))
    _draw_fish_window(ctx, screen, world)
    # Ensure we actually built a thumb
    assert captured, "no SpriteCache.get call captured for dead thumbnail"
    # Dead adult uses adult geometry (base 60x40 inside 72x72 box) -> 72x48
    assert (captured["w"], captured["h"]) == (72, 48), f"dead size wrong: got {(captured['w'], captured['h'])}, expected (72, 48)"
    assert captured["dead"] is True, "dead thumbnail must request dead=True (grayscale+vflip path)"
    assert captured["hflip"] is False, "card thumbs must keep stable facing (no live hflip)"
    # Variant can be "normal" for adult, since 'dead' flag drives the grayscale/vflip.
def test_card_egg_uses_egg_asset_and_fits_box(monkeypatch):
    """
    Egg thumbnails must use the 'egg' asset, fitted to the card box (72x72).
    """
    world = World()
    ctx, screen = _make_ctx_assets_screen()
    tank = _tank(world)
    _fish(world, tank, stage="Egg", brain="Cruise")
    # Publish finals (harmless for cards, keeps parity with other tests)
    SpriteRenderSystem(screen, ctx.assets, ctx).update(world, dt=0.016)
    # Provide a known egg surface and capture asset key usage
    egg_surface = pygame.Surface((40, 40), pygame.SRCALPHA)
    seen_keys = []
    original_assets_get = ctx.assets.get
    def assets_get(key):
        seen_keys.append(key)
        if key == "egg":
            return egg_surface
        return original_assets_get(key)
    monkeypatch.setattr(ctx.assets, "get", assets_get)
    # Capture SpriteCache.get usage
    calls, wrapped = _wrap_spritecache_get_for_capture()
    monkeypatch.setattr(SpriteCache.shared(), "get", wrapped)
    _draw_fish_window(ctx, screen, world)
    assert calls.first is not None, "no SpriteCache.get call captured for egg thumbnail"
    assert "egg" in seen_keys, f"egg asset not requested; seen keys: {seen_keys}"
    # Square egg 40x40 into 72 box => 72x72
    assert (calls.first["w"], calls.first["h"]) == (72, 72), f"egg size wrong: got {(calls.first['w'], calls.first['h'])}"
    assert calls.first["dead"] is False
    assert calls.first["variant"] == "normal"
def test_card_senior_uses_senior_variant_and_size(monkeypatch):
    """
    Senior (alive) thumbnails must use variant='senior' with style and adult geometry (72x48).
    """
    world = World()
    ctx, screen = _make_ctx_assets_screen()
    tank = _tank(world)
    _fish(world, tank, stage="Senior", brain="Cruise")
    SpriteRenderSystem(screen, ctx.assets, ctx).update(world, dt=0.016)
    calls, wrapped = _wrap_spritecache_get_for_capture()
    monkeypatch.setattr(SpriteCache.shared(), "get", wrapped)
    _draw_fish_window(ctx, screen, world)
    assert calls.first is not None, "no SpriteCache.get call captured for senior thumbnail"
    assert (calls.first["w"], calls.first["h"]) == (72, 48), f"senior size wrong: got {(calls.first['w'], calls.first['h'])}, expected (72,48)"
    assert calls.first["dead"] is False
    assert calls.first["variant"] == "senior", f"expected variant=senior, got {calls.first['variant']}"
    style = calls.first["senior_style"]
    assert isinstance(style, dict) and "desaturate" in style and "tint" in style, f"missing senior style fields: {style}"
def test_card_senior_dead_uses_dead_variant_not_senior(monkeypatch):
    """
    Senior+Dead must request dead=True and NOT apply senior variant; size stays adult geometry (72x48).
    """
    world = World()
    ctx, screen = _make_ctx_assets_screen()
    tank = _tank(world)
    _fish(world, tank, stage="Senior", brain="Dead")
    SpriteRenderSystem(screen, ctx.assets, ctx).update(world, dt=0.016)
    calls, wrapped = _wrap_spritecache_get_for_capture()
    monkeypatch.setattr(SpriteCache.shared(), "get", wrapped)
    _draw_fish_window(ctx, screen, world)
    assert calls.first is not None, "no SpriteCache.get call captured for senior-dead thumbnail"
    assert (calls.first["w"], calls.first["h"]) == (72, 48)
    assert calls.first["dead"] is True
    assert calls.first["variant"] == "normal", f"dead senior should not use 'senior' variant, got {calls.first['variant']}"
```
# === FILE END: tests\test_fish_window_thumbs.py ===
# === FILE START: tests\test_fsm_cruise.py ===
```python
# Deterministic cruise timing => Idle after max time.
from world import World
from ecs.fsm.cruise_state import CruiseState
from ecs.views.fish_view import FishView
from ecs.components.fish.brain_component import Brain
from ecs.components.core.position_component import Position
from ecs.components.core.velocity_component import Velocity
from ecs.components.fish.motion_component import MotionParams
from ecs.components.fish.hunger_component import Hunger
from ecs.components.core.sprite_component import Sprite
from ecs.components.fish.behavior_tuning import BehaviorTuning
from ecs.components.fish.target_intent_component import TargetIntent
from ecs.components.fish.steering_intent_component import SteeringIntent
from ecs.components.fish.speed_intent_component import SpeedIntent
def _make_view():
    brain = Brain(state="Cruise")
    pos = Position(0, 0)
    vel = Velocity(0.0, 0.0)
    motion = MotionParams(max_speed=100.0, acceleration=200.0, turn_speed=8.0)
    hunger = Hunger(hunger=50.0, hunger_rate=0.0, hunger_max=100.0)
    sprite = Sprite("goldfish", 60, 40)
    tuning = BehaviorTuning({
        "cruise_min_time": 0.05,
        "cruise_max_time": 0.06,
        "cruise_arrival_radius": 2.0,
        "cruise_speed_factor": 0.2,
        "transition_to_idle_chance": 0.0,
    })
    target = TargetIntent(0.0, 0.0)
    steer = SteeringIntent()
    speed = SpeedIntent(0.0)
    return FishView(brain, pos, vel, motion, hunger, sprite, tuning, target, steer, speed), speed
def test_cruise_transitions_to_idle_after_max_time(make_context, dt):
    world = World(); ctx = make_context()
    view, speed = _make_view()
    state = CruiseState()
    state.enter(view, ctx)
    result = None
    for _ in range(30):  # ~0.48 s
        result = state.update(view, speed, ctx, dt, world)
        if result:
            break
    assert result == "Idle"
    assert view.brain.state == "Cruise"  # state machine proposes; transition system would switch
```
# === FILE END: tests\test_fsm_cruise.py ===
# === FILE START: tests\test_fsm_food_chain.py ===
```python
from world import World
from game_context import GameContext
from ecs.components.core.position_component import Position
from ecs.components.core.velocity_component import Velocity
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.tank_component import Tank
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.fish.brain_component import Brain
from ecs.components.fish.motion_component import MotionParams
from ecs.components.fish.hunger_component import Hunger
from ecs.components.fish.behavior_tuning import BehaviorTuning
from ecs.components.fish.target_intent_component import TargetIntent
from ecs.components.fish.steering_intent_component import SteeringIntent
from ecs.components.fish.speed_intent_component import SpeedIntent
from ecs.components.tags.food_pellet_component import FoodPellet
from ecs.systems.ai.behavior_system import BehaviorSystem
from ecs.systems.ai.state_override_system import StateOverrideSystem
from ecs.systems.ai.state_transition_system import StateTransitionSystem
from ecs.systems.gameplay.hunger_system import HungerSystem
# We don't need MovementSystem for this test because we spawn the pellet
# inside the immediate eat radius.
def _tank(world: World):
    t = world.create_entity()
    world.add_component(t, Tank())
    world.add_component(t, Position(0.0, 0.0))
    return t
def _pellet_at(world: World, x: float, y: float):
    p = world.create_entity()
    world.add_component(p, Position(x, y))
    # Make the pellet generous for collision to simplify the test.
    world.add_component(p, Sprite("pellet", 16, 16))
    world.add_component(p, FoodPellet(nutrition=20.0, radius_scale=1.35))
    return p
def _fish_entity(world: World, tank, x: float, y: float):
    e = world.create_entity()
    world.add_component(e, TankRef(tank))
    world.add_component(e, Position(x, y))
    world.add_component(e, Velocity(0.0, 0.0))
    world.add_component(e, Sprite("goldfish", 60, 40))
    world.add_component(e, Brain(state="Idle"))  # start idle; overrides will nudge it
    world.add_component(e, MotionParams(max_speed=300.0, acceleration=4000.0, turn_speed=999.0))
    # Start somewhat hungry so override pushes toward food seeking.
    world.add_component(e, Hunger(hunger=40.0, hunger_rate=0.0, hunger_max=100.0))
    # Use tuning keys actually consumed by our FSM paths
    world.add_component(
        e,
        BehaviorTuning(
            {
                "food_detect_radius": 250.0,
                "food_seek_threshold": 0.80,
                "chase_food_speed_factor": 1.0,
                "eat_extra_margin": 12.0,
                "mouth_radius_factor": 0.40,
                "health_regen_factor": 0.0,
                "health_regen_threshold": 1.0,
                "health_starve_factor": 0.5,
                "noise": 0.0,
            }
        ),
    )
    world.add_component(e, TargetIntent(x, y))
    world.add_component(e, SteeringIntent(0.0, 0.0))
    world.add_component(e, SpeedIntent(desired_speed=0.0))
    return e
def test_chase_and_eat_increases_hunger_and_removes_pellet(make_context, dt):
    world = World()
    ctx: GameContext = make_context()
    tank = _tank(world)
    fish = _fish_entity(world, tank, 100.0, 100.0)
    # Place the pellet well within immediate eat distance:
    # Align the pellet roughly at the fish's nose by centering near sprite center.
    pos = world.get_component(fish, Position)
    spr = world.get_component(fish, Sprite)
    # Put pellet a little to the right of the fish center to be "in front".
    pellet = _pellet_at(world, x=pos.x + spr.base_w * 0.5 + 2.0, y=pos.y + spr.base_h * 0.5)
    behavior = BehaviorSystem(ctx)
    override = StateOverrideSystem()
    transition = StateTransitionSystem(ctx, behavior)
    hunger_sys = HungerSystem()
    before = world.get_component(fish, Hunger).hunger
    # Run a handful of frames:
    #  1) Override should push Idle -> LookForFood (hungry).
    #  2) Behavior should find the nearby pellet -> ChaseFood.
    #  3) ChaseFood should immediately satisfy the eat threshold and destroy the pellet.
```
# === FILE END: tests\test_fsm_food_chain.py ===
# === FILE START: tests\test_modal_strict_blocking.py ===
```python
# tests/test_modal_strict_blocking.py
import os
os.environ.setdefault("SDL_AUDIODRIVER", "dummy")
os.environ.setdefault("SDL_VIDEODRIVER", "dummy")
import pygame
import pytest
from world import World
from game_context import GameContext
from ecs.systems.ui.mouse_system import MouseSystem
from ecs.systems.ui.fish_window_system import FishWindowSystem
LMB = 1
@pytest.fixture(scope="module", autouse=True)
def _pg():
    pygame.init()
    try:
        pygame.display.set_mode((640, 480))
        yield
    finally:
        pygame.quit()
class Ctx(GameContext):
    def __init__(self):
        super().__init__()
        # toolbar rects
        self.toolbar_button_rect = pygame.Rect(10, 10, 60, 30)  # FEED
        self.toolbar_egg_rect = pygame.Rect(80, 10, 60, 30)     # EGG
        # tank covers screen
        self.tank_screen_x, self.tank_screen_y = 0, 0
        sw, sh = pygame.display.get_surface().get_size()
        self.tank_screen_w, self.tank_screen_h = sw, sh
        # minimal assets handle
        self.assets = type("A", (), {"get": lambda *_: pygame.Surface((1,1), pygame.SRCALPHA)})()
def _ensure_modal_flags(ctx: GameContext):
    """Guarantee strict-modal gating even if the window system didn't set it."""
    if not getattr(ctx, "fish_window_rect", None):
        # Default window at top-right-ish for tests
        sw, sh = pygame.display.get_surface().get_size()
        win_w, win_h = 420, 520
        win_x, win_y = sw - win_w - 20, 60
        ctx.fish_window_rect = pygame.Rect(win_x, win_y, win_w, win_h)
    if not getattr(ctx, "fish_close_rect", None):
        close_size = 18
        ctx.fish_close_rect = pygame.Rect(
            ctx.fish_window_rect.right - 12 - close_size,
            ctx.fish_window_rect.y + 12,
            close_size,
            close_size,
        )
    ctx.ui_modal_active = True
    ctx.ui_modal_whitelist = [ctx.fish_window_rect, ctx.fish_close_rect]
def _open_modal(ctx, screen, world):
    ctx.show_fish_window = True
    # Try to let the real system populate rects; if not, force them.
    FishWindowSystem(screen, ctx.assets, ctx).update(world, 0.016)
    pygame.display.flip()
    _ensure_modal_flags(ctx)
def _mouse_system(ctx, screen):
    return MouseSystem(ctx, screen, ctx.assets)
def _click_up(ms: MouseSystem, x: int, y: int, button: int):
    evt = pygame.event.Event(pygame.MOUSEBUTTONUP, {"pos": (x, y), "button": button})
    ms.handle_mouse_event(evt)
def test_modal_blocks_toolbar_and_world():
    world = World()
    screen = pygame.display.get_surface()
    ctx = Ctx()
    _open_modal(ctx, screen, world)
    ms = _mouse_system(ctx, screen)
    _click_up(ms, 15, 15, LMB)  # FEED
    assert not getattr(ctx, "feeding_enabled", False), "modal must block toolbar FEED"
    _click_up(ms, 85, 15, LMB)  # EGG
    assert not getattr(ctx, "egging_enabled", False), "modal must block toolbar EGG"
    # world clicks are swallowed (no side-effects expected)
    _click_up(ms, 200, 200, LMB)
def test_modal_close_button_closes():
    world = World()
    screen = pygame.display.get_surface()
    ctx = Ctx()
    _open_modal(ctx, screen, world)
    ms = _mouse_system(ctx, screen)
    close_r = getattr(ctx, "fish_close_rect", None)
    assert close_r, "no close rect"
    cx, cy = close_r.center
    _click_up(ms, cx, cy, LMB)
    assert ctx.show_fish_window is False
def test_after_modal_closes_toolbar_and_placement_work():
    world = World()
    screen = pygame.display.get_surface()
    ctx = Ctx()
    _open_modal(ctx, screen, world)
    ms = _mouse_system(ctx, screen)
    # close
    close_r = getattr(ctx, "fish_close_rect", None)
    _click_up(ms, *close_r.center, LMB)
    # emulate next frame cleanup
    ctx.ui_modal_active = False
    ctx.ui_modal_whitelist = None
    _click_up(ms, 15, 15, LMB)
    assert getattr(ctx, "feeding_enabled", False) is True
```
# === FILE END: tests\test_modal_strict_blocking.py ===
# === FILE START: tests\test_movement_system.py ===
```python
from math import hypot
from world import World
from game_context import GameContext
from ecs.components.core.position_component import Position
from ecs.components.core.velocity_component import Velocity
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.tank_component import Tank
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.fish.motion_component import MotionParams
from ecs.components.fish.target_intent_component import TargetIntent
from ecs.components.fish.steering_intent_component import SteeringIntent
from ecs.components.fish.speed_intent_component import SpeedIntent
from ecs.systems.core.movement_system import MovementSystem
def test_movement_updates_position(make_world, make_context, make_tank):
    world: World = make_world()
    context: GameContext = make_context()
    # Tank (MovementSystem requires TankRef on fish)
    tank = make_tank(world, x=0, y=0, w=800, h=600)
    # Minimal fish with the components MovementSystem expects
    e = world.create_entity()
    world.add_component(e, TankRef(tank))
    world.add_component(e, Position(100.0, 100.0))
    world.add_component(e, Velocity(10.0, 5.0))
    world.add_component(e, Sprite("goldfish", base_w=60, base_h=40))
    world.add_component(e, MotionParams(max_speed=1000.0, acceleration=10000.0, turn_speed=999.0))
    # Point the target roughly along the current velocity direction
    pos = world.get_component(e, Position)
    vel = world.get_component(e, Velocity)
    speed_mag = hypot(vel.dx, vel.dy)
    world.add_component(e, TargetIntent(pos.x + vel.dx * 10.0, pos.y + vel.dy * 10.0))
    world.add_component(e, SteeringIntent(0.0, 0.0))
    world.add_component(e, SpeedIntent(desired_speed=speed_mag))
    MovementSystem(context).update(world, dt=1.0)
    pos_after = world.get_component(e, Position)
    assert pos_after.x > 100.0
    assert pos_after.y > 100.0
def test_hysteresis_facing_stability():
    """
    Only assert obvious left/right flips (far from deadzone).
    """
    from ecs.systems.renderers.draw_sprite import choose_facing
    spr = Sprite("goldfish", base_w=60, base_h=40)
    pos = Position(50, 50)
    # Far right -> should face right
    target = TargetIntent(300, 50)
    face_right, _ = choose_facing(spr, Velocity(0.0, 0.0), target, pos, False)
    assert face_right is True
    # Far left -> should face left
    target = TargetIntent(-300, 50)
    face_right, _ = choose_facing(spr, Velocity(0.0, 0.0), target, pos, True)
    assert face_right is False
```
# === FILE END: tests\test_movement_system.py ===
# === FILE START: tests\test_panel_manager_grid.py ===
```python
# tests/test_panel_manager_grid.py
import os
os.environ.setdefault("SDL_AUDIODRIVER", "dummy")
os.environ.setdefault("SDL_VIDEODRIVER", "dummy")
import pygame
import pytest
from types import SimpleNamespace
# Systems under test
from ecs.systems.ui.widgets.panel_manager_system import PanelManagerSystem
from ecs.systems.ui.mouse_system import MouseSystem
# --- Minimal world/components stubs ---
class _Species:
    def __init__(self, display_name: str, species_id: str = "goldfish"):
        self.display_name = display_name
        self.species_id = species_id
class _WorldStub:
    """Enough of the world API for PanelManagerSystem.open_fish(...) title lookup."""
    def get_component(self, entity_id, comp_type):
        if comp_type.__name__ == "Species":
            return _Species(display_name=f"Fish {entity_id}")
        return None
# --- Pygame bootstrap ---
@pytest.fixture(scope="module", autouse=True)
def _pygame_boot():
    pygame.init()
    try:
        # a modest screen; PanelManagerSystem reads size for grid math
        pygame.display.set_mode((800, 600))
        yield
    finally:
        pygame.quit()
def _make_ctx_screen_assets():
    ctx = SimpleNamespace()
    ctx.ui = {}             # optional UI config dict
    ctx.ui_panels = []      # PanelManager populates/reads this
    # legacy flags used by MouseSystem global cancel path (kept harmless)
    ctx.show_fish_window = False
    ctx.show_fish_inspector = False
    screen = pygame.display.get_surface()
    assets = SimpleNamespace()  # not used by these tests
    return ctx, screen, assets
# -----------------------------
# Tests
# -----------------------------
def test_open_panels_are_compact_grid_from_top_left():
    """
    Open three panels and verify they occupy slot 0,1,2 (top-left grid, left->right then wrap).
    """
    ctx, screen, assets = _make_ctx_screen_assets()
    mgr = PanelManagerSystem(screen, assets, ctx)
    world = _WorldStub()
    # Open three distinct fish panels
    mgr.open_fish(world, 101)
    mgr.open_fish(world, 202)
    mgr.open_fish(world, 303)
    assert len(ctx.ui_panels) == 3
    # Expected positions according to manager's own grid function
    exp0 = mgr._grid_slot_xy(0)
    exp1 = mgr._grid_slot_xy(1)
    exp2 = mgr._grid_slot_xy(2)
    # Actual positions
    p0, p1, p2 = ctx.ui_panels[0], ctx.ui_panels[1], ctx.ui_panels[2]
    got0 = (p0.x, p0.y)
    got1 = (p1.x, p1.y)
    got2 = (p2.x, p2.y)
    assert got0 == exp0, f"slot 0 mismatch: got {got0}, expected {exp0}"
    assert got1 == exp1, f"slot 1 mismatch: got {got1}, expected {exp1}"
    assert got2 == exp2, f"slot 2 mismatch: got {got2}, expected {exp2}"
def test_rmb_closes_top_panel_lifo_and_reflows_compact(monkeypatch):
    """
    RMB-up closes the top-most panel (highest z). After each close, remaining panels reflow
    to compact grid slots (0..n-1).
    """
    ctx, screen, assets = _make_ctx_screen_assets()
    mgr = PanelManagerSystem(screen, assets, ctx)
    world = _WorldStub()
    # Wire MouseSystem to route RMB closings into panel manager
    mouse = MouseSystem(ctx, screen, assets)
    mouse.set_panel_manager(mgr)
    mouse.set_world_ref(world)  # not used in this test, safe
    # Build three panels; last opened should be the top-most (highest z)
    mgr.open_fish(world, 1)
    mgr.open_fish(world, 2)
    mgr.open_fish(world, 3)
    assert len(ctx.ui_panels) == 3
    # Simulate RMB-up (MouseSystem uses pygame.mouse.get_pos())
    monkeypatch.setattr(pygame.mouse, "get_pos", lambda: (0, 0))
    evt_rmb = pygame.event.Event(pygame.MOUSEBUTTONUP, {"button": 3, "pos": (0, 0)})
    # First RMB should close the top-most (fish 3)
    mouse.handle_mouse_event(evt_rmb)
    assert len(ctx.ui_panels) == 2, "expected one panel to be closed by first RMB"
    # Remaining panels must occupy slots 0 and 1 compactly
    exp0 = mgr._grid_slot_xy(0)
    exp1 = mgr._grid_slot_xy(1)
    got_pos = {(p.x, p.y) for p in ctx.ui_panels}
    assert exp0 in got_pos and exp1 in got_pos, f"panels not reflowed compactly after close; got {got_pos}, expected {exp0} & {exp1}"
    # Second RMB should close the next top-most → 1 panel remains at slot 0
    mouse.handle_mouse_event(evt_rmb)
    assert len(ctx.ui_panels) == 1, "expected two panels closed after second RMB"
    exp0 = mgr._grid_slot_xy(0)
    only = ctx.ui_panels[0]
    assert (only.x, only.y) == exp0, f"remaining panel not at slot 0 after reflow; got {(only.x, only.y)}, expected {exp0}"
    # Third RMB should close the last panel; then it falls back to global cancel (no crash)
    mouse.handle_mouse_event(evt_rmb)
    assert len(ctx.ui_panels) == 0, "expected all panels closed after third RMB"
```
# === FILE END: tests\test_panel_manager_grid.py ===
# === FILE START: tests\test_placement_public.py ===
```python
# tests/test_placement_public.py
import math
import pytest
from ecs.systems.ui.placement_system import PlacementSystem
from ecs.components.core.position_component import Position
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.tags.food_pellet_component import FoodPellet
from tests.helpers import make_world, make_context
# --- World compatibility helpers --------------------------------------------
def _get_component(world, e, Comp):
    """
    Return component instance or None, working across different ECS 'World' APIs.
    Tries: get_component -> component_for_entity -> components_for_entity
    """
    # Most common in your project
    if hasattr(world, "get_component"):
        try:
            return world.get_component(e, Comp)
        except Exception:
            pass
    # Esper-like
    if hasattr(world, "component_for_entity"):
        try:
            return world.component_for_entity(e, Comp)
        except Exception:
            return None
    # Fallback: scan tuple from components_for_entity if available
    if hasattr(world, "components_for_entity"):
        try:
            comps = world.components_for_entity(e)
            for c in comps:
                if isinstance(c, Comp):
                    return c
        except Exception:
            pass
    return None
def _has_component(world, e, Comp) -> bool:
    # If the world *does* provide has_component, use it.
    hc = getattr(world, "has_component", None)
    if callable(hc):
        try:
            return bool(hc(e, Comp))
        except Exception:
            # fall through to generic check
            pass
    return _get_component(world, e, Comp) is not None
def _iter_entities(world):
    """
    Robustly iterate entities whether world.entities is a method or a collection.
    """
    ents_attr = getattr(world, "entities", None)
    if callable(ents_attr):
        try:
            return list(ents_attr())
        except TypeError:
            pass
    elif ents_attr is not None:
        try:
            return list(ents_attr)
        except TypeError:
            pass
    # Other common names
    for name in ("all_entities", "_entities"):
        cand = getattr(world, name, None)
        if cand is None:
            continue
        if callable(cand):
            try:
                return list(cand())
            except TypeError:
                continue
        try:
            return list(cand)
        except TypeError:
            continue
    return []
# --- Click wiring helper -----------------------------------------------------
def _send_click(sys, world, x, y):
    """
    Try common public APIs. Return True if we managed to send a click.
    Prefers PlacementSystem.enqueue_click which your system exposes.
    """
    for name in ("enqueue_click", "on_click", "queue_click", "handle_click", "emit_click"):
        fn = getattr(sys, name, None)
        if callable(fn):
            fn(x, y)
            return True
    # Public queue attribute
    if hasattr(sys, "clicks") and isinstance(sys.clicks, list):
        sys.clicks.append((x, y))
        return True
    # Event-based fallback (optional)
    event_classes = []
    for dotted in (
        "ecs.components.input.click_event.ClickEvent",
        "ecs.components.input.mouse_click.MouseClick",
        "ecs.components.input.events.MouseClick",
    ):
        try:
            module_path, cls_name = dotted.rsplit(".", 1)
            mod = __import__(module_path, fromlist=[cls_name])
            event_classes.append(getattr(mod, cls_name))
        except Exception:
            pass
    if event_classes:
        Evt = event_classes[0]
        e = world.create_entity()
        world.add_component(e, Evt(x=int(x), y=int(y)))
        return True
    return False
def _find_spawned_pellets(world):
    pellets = []
    for e in _iter_entities(world):
        if _has_component(world, e, FoodPellet) and _has_component(world, e, Position):
            pellets.append((e, _get_component(world, e, Position)))
    return pellets
# --- The test ----------------------------------------------------------------
def test_click_spawns_pellet_at_logical_click_point():
    """
    PlacementSystem:
      - expects enqueue_click(x, y)
      - spawns pellets when context.feeding_enabled is True
      - requires set_tank(tank_entity) and that tank has a Position
      - maps screen (x, y) -> logical ((x - sx)/scale, (y - sy)/scale)
    """
    world = make_world()
    ctx = make_context()
    # Screen rect and scale for screen->logical mapping
    ctx.tank_screen_x = 100
    ctx.tank_screen_y = 100
    ctx.tank_screen_w = 600
    ctx.tank_screen_h = 400
    ctx.tank_scale = 1.0
    ctx.feeding_enabled = True
    # Create a tank entity and register it with the system
    tank = world.create_entity()
    world.add_component(tank, Position(0.0, 0.0))
    world.add_component(tank, TankRef(tank))
    world.add_component(tank, Sprite("tank", base_w=600, base_h=400))
    sys = PlacementSystem(ctx)
    sys.set_tank(tank)
    # Click at screen center horizontally, 1/4 down vertically
    click_x = ctx.tank_screen_x + ctx.tank_screen_w // 2   # 100 + 300 = 400
    click_y = ctx.tank_screen_y + ctx.tank_screen_h // 4   # 100 + 100 = 200
    if not _send_click(sys, world, click_x, click_y):
        pytest.skip("PlacementSystem exposes no recognized click API/mode in this project")
    # Process the click this frame
    sys.update(world, dt=0.016)
    # Find spawned pellets
    pellets = _find_spawned_pellets(world)
    assert pellets, "No FoodPellet entity was spawned after click"
    # Assert expected logical position mapping
    _, pos = pellets[0]
    expected_x = (click_x - ctx.tank_screen_x) / ctx.tank_scale  # 300
    expected_y = (click_y - ctx.tank_screen_y) / ctx.tank_scale  # 100
    assert math.isclose(pos.x, expected_x, rel_tol=0.0, abs_tol=1e-6)
    assert math.isclose(pos.y, expected_y, rel_tol=0.0, abs_tol=1e-6)
```
# === FILE END: tests\test_placement_public.py ===
# === FILE START: tests\test_resize_system.py ===
```python
# Resize updates context and tank bounds/position.
from ecs.systems.core.resize_system import ResizeSystem
from ecs.components.core.bounds_component import Bounds
from ecs.components.core.position_component import Position
from ecs.components.core.tank_component import Tank
from world import World
def test_resize_updates_context_and_tank(make_context):
    world = World()
    ctx = make_context()
    # logical tank: 400x300
    ctx.logical_tank_w = 400
    ctx.logical_tank_h = 300
    # one tank entity
    tank = world.create_entity()
    world.add_component(tank, Tank())
    world.add_component(tank, Position(0, 0))
    world.add_component(tank, Bounds(400, 300))
    # request resize to exactly logical size -> scale 1.0
    ctx.needs_resize = True
    ctx.new_screen_w = 400
    ctx.new_screen_h = 300
    sys = ResizeSystem(ctx)
    sys.update(world, dt=0.0)
    b = world.get_component(tank, Bounds)
    p = world.get_component(tank, Position)
    assert (b.width, b.height) == (400, 300)
    assert (p.x, p.y) == (0, 0)
    assert abs(ctx.tank_scale - 1.0) < 1e-6
```
# === FILE END: tests\test_resize_system.py ===
# === FILE START: tests\test_right_click_cancel.py ===
```python
# tests/test_right_click_cancel.py
import os
os.environ.setdefault("SDL_AUDIODRIVER", "dummy")
os.environ.setdefault("SDL_VIDEODRIVER", "dummy")
import pygame
import pytest
from world import World
from game_context import GameContext
from ecs.systems.ui.mouse_system import MouseSystem
from ecs.systems.ui.fish_window_system import FishWindowSystem
RMB = 3
@pytest.fixture(scope="module", autouse=True)
def _pg():
    pygame.init()
    try:
        pygame.display.set_mode((800, 600))
        yield
    finally:
        pygame.quit()
def _make_ctx_assets_screen():
    ctx = GameContext()
    screen = pygame.display.get_surface()
    # toolbar rects so state exists
    ctx.toolbar_button_rect = pygame.Rect(10, 10, 60, 30)
    ctx.toolbar_egg_rect = pygame.Rect(80, 10, 60, 30)
    ctx.assets = type("A", (), {"get": lambda *_: pygame.Surface((1,1), pygame.SRCALPHA)})()
    return ctx, screen
def _mouse_system(ctx, screen):
    return MouseSystem(ctx, screen, ctx.assets)
def _open_modal(ctx, screen, world):
    ctx.show_fish_window = True
    FishWindowSystem(screen, ctx.assets, ctx).update(world, 0.016)
    pygame.display.flip()
def _rmb_up(ms: MouseSystem, x: int, y: int):
    evt = pygame.event.Event(pygame.MOUSEBUTTONUP, {"pos": (x, y), "button": RMB})
    ms.handle_mouse_event(evt)
def test_rmb_closes_modal_and_clears_tools_and_flags():
    world = World()
    ctx, screen = _make_ctx_assets_screen()
    # Enable both tools to verify they get cleared by RMB
    ctx.egging_enabled = True
    ctx.feeding_enabled = True
    # Open the modal (Fish window)
    _open_modal(ctx, screen, world)
    # Preconditions: strict modal flags and rects should be present
    assert getattr(ctx, "ui_modal_active", False) is True
    assert getattr(ctx, "fish_window_rect", None) is not None
    assert getattr(ctx, "fish_close_rect", None) is not None
    assert ctx.show_fish_window is True
    # Inject right-click (on mouse UP)
    ms = _mouse_system(ctx, screen)
    _rmb_up(ms, 10, 10)
    # Postconditions
    assert ctx.show_fish_window is False, "RMB-UP should close fish modal immediately"
    assert getattr(ctx, "egging_enabled", False) is False
    assert getattr(ctx, "feeding_enabled", False) is False
def test_rmb_without_modal_disables_tools_but_keeps_modal_flags_off():
    world = World()
    ctx, screen = _make_ctx_assets_screen()
    # Ensure modal is not open
    ctx.show_fish_window = False
    ctx.ui_modal_active = False
    ctx.ui_modal_whitelist = []
    # Turn tools on
    ctx.egging_enabled = True
    ctx.feeding_enabled = True
    # RMB-UP
    ms = _mouse_system(ctx, screen)
    _rmb_up(ms, 100, 100)
    # Tools should be off; modal flags remain off
    assert getattr(ctx, "egging_enabled", False) is False
    assert getattr(ctx, "feeding_enabled", False) is False
    assert getattr(ctx, "ui_modal_active", False) is False
```
# === FILE END: tests\test_right_click_cancel.py ===
# === FILE START: tests\test_smoke_startup.py ===
```python
# Basic scene wiring smoke test; ensures scene can construct under dummy SDL.
import pygame
import pytest
def test_scene_initializes(make_context):
    try:
        from scenes.tank_scene import TankScene
    except Exception:
        pytest.skip("TankScene not available")
    ctx = make_context()
    # create a dummy screen surface (no window needed with dummy driver)
    screen = pygame.display.set_mode((800, 600))
    scene = TankScene(ctx, screen)
    scene.update(0.0)
    assert scene is not None
```
# === FILE END: tests\test_smoke_startup.py ===
# === FILE START: tests\test_strict_modal.py ===
```python
# tests/test_strict_modal.py
import os
os.environ.setdefault("SDL_AUDIODRIVER", "dummy")
os.environ.setdefault("SDL_VIDEODRIVER", "dummy")
import pygame
import pytest
from world import World
from game_context import GameContext
from ecs.systems.ui.mouse_system import MouseSystem
from ecs.systems.ui.fish_window_system import FishWindowSystem
LMB = 1
RMB = 3
@pytest.fixture(scope="module", autouse=True)
def _pg():
    pygame.init()
    try:
        pygame.display.set_mode((800, 600))
        yield
    finally:
        pygame.quit()
class Ctx(GameContext):
    def __init__(self):
        super().__init__()
        # toolbar rects
        self.toolbar_button_rect = pygame.Rect(10, 10, 60, 30)  # FEED
        self.toolbar_egg_rect = pygame.Rect(80, 10, 60, 30)     # EGG
        # tank covers screen
        self.tank_screen_x, self.tank_screen_y = 0, 0
        sw, sh = pygame.display.get_surface().get_size()
        self.tank_screen_w, self.tank_screen_h = sw, sh
        # minimal assets handle
        self.assets = type("A", (), {"get": lambda *_: pygame.Surface((1,1), pygame.SRCALPHA)})()
def _ensure_modal_flags(ctx: GameContext):
    if not getattr(ctx, "fish_window_rect", None):
        sw, sh = pygame.display.get_surface().get_size()
        win_w, win_h = 420, 520
        win_x, win_y = sw - win_w - 20, 60
        ctx.fish_window_rect = pygame.Rect(win_x, win_y, win_w, win_h)
    if not getattr(ctx, "fish_close_rect", None):
        close_size = 18
        ctx.fish_close_rect = pygame.Rect(
            ctx.fish_window_rect.right - 12 - close_size,
            ctx.fish_window_rect.y + 12,
            close_size,
            close_size,
        )
    ctx.ui_modal_active = True
    ctx.ui_modal_whitelist = [ctx.fish_window_rect, ctx.fish_close_rect]
def _open_modal(ctx: GameContext, screen, world: World):
    ctx.show_fish_window = True
    FishWindowSystem(screen, ctx.assets, ctx).update(world, 0.016)
    pygame.display.flip()
    _ensure_modal_flags(ctx)
def _mouse_system(ctx, screen):
    ms = MouseSystem(ctx, screen, ctx.assets)
    return ms
def _click_up(ms: MouseSystem, x: int, y: int, button: int):
    evt = pygame.event.Event(pygame.MOUSEBUTTONUP, {"pos": (x, y), "button": button})
    ms.handle_mouse_event(evt)
def test_modal_blocks_toolbar_and_world():
    world = World()
    screen = pygame.display.get_surface()
    ctx = Ctx()
    _open_modal(ctx, screen, world)
    ms = _mouse_system(ctx, screen)
    # Toolbar clicks should be ignored while modal is active
    _click_up(ms, 15, 15, LMB)    # FEED
    assert not getattr(ctx, "feeding_enabled", False), "modal must block toolbar FEED"
    _click_up(ms, 85, 15, LMB)    # EGG
    assert not getattr(ctx, "egging_enabled", False), "modal must block toolbar EGG"
    # World/tank clicks also blocked
    _click_up(ms, 200, 200, LMB)
def test_modal_close_button_closes_and_unblocks():
    world = World()
    screen = pygame.display.get_surface()
    ctx = Ctx()
    _open_modal(ctx, screen, world)
    ms = _mouse_system(ctx, screen)
    # Close via the X rect (provided or synthesized)
    close_r = getattr(ctx, "fish_close_rect", None)
    assert close_r, "close rect missing"
    cx, cy = close_r.center
    _click_up(ms, cx, cy, LMB)
    # Modal flag down immediately
    assert ctx.show_fish_window is False
    # Next frame, scene would clear strict flags; emulate:
    ctx.ui_modal_active = False
    ctx.ui_modal_whitelist = None
    # Toolbar FEED now toggles
    _click_up(ms, 15, 15, LMB)
    assert getattr(ctx, "feeding_enabled", False) is True
def test_after_modal_closes_toolbar_works():
    world = World()
    screen = pygame.display.get_surface()
    ctx = Ctx()
    _open_modal(ctx, screen, world)
    ms = _mouse_system(ctx, screen)
    # Close first
    close_r = getattr(ctx, "fish_close_rect", None)
    cx, cy = close_r.center
    _click_up(ms, cx, cy, LMB)
    # Simulate next frame where strict modal is cleared
    ctx.ui_modal_active = False
    ctx.ui_modal_whitelist = None
    _click_up(ms, 15, 15, LMB)
    assert getattr(ctx, "feeding_enabled", False) is True
```
# === FILE END: tests\test_strict_modal.py ===
# === FILE START: tests\test_world_core.py ===
```python
# Core ECS world behaviors: creation, indexing, queries, destruction.
from world import World
from ecs.components.core.position_component import Position
from ecs.components.core.velocity_component import Velocity
def test_entities_with_intersection():
    world = World()
    e1 = world.create_entity(); world.add_component(e1, Position(1, 2))
    e2 = world.create_entity(); world.add_component(e2, Position(3, 4)); world.add_component(e2, Velocity(0, 0))
    e3 = world.create_entity(); world.add_component(e3, Velocity(0, 0))
    only_pos = set(world.entities_with(Position))
    both = set(world.entities_with(Position, Velocity))
    only_vel = set(world.entities_with(Velocity))
    assert e1 in only_pos and e2 in only_pos and e3 not in only_pos
    assert e2 in both and e1 not in both and e3 not in both
    assert e2 in only_vel and e3 in only_vel and e1 not in only_vel
def test_destroy_entity_cleans_indices():
    world = World()
    e = world.create_entity()
    world.add_component(e, Position(10, 20))
    world.add_component(e, Velocity(1, 2))
    assert e in set(world.entities_with(Position, Velocity))
    world.destroy_entity(e)
    assert e not in world.entities
    assert e not in set(world.entities_with(Position))
    assert e not in set(world.entities_with(Velocity))
```
# === FILE END: tests\test_world_core.py ===
# === FILE START: utils\__init__.py ===
```python
```
# === FILE END: utils\__init__.py ===
# === FILE START: utils\geometry.py ===
```python
# utils/geometry.py
from typing import Optional, Tuple
from ecs.components.core.position_component import Position
from ecs.components.core.sprite_component import Sprite
def get_mouth_logical(
    pos: Position,
    spr: Sprite,
    *,
    face_right: Optional[bool] = None,
    target_x: Optional[float] = None,
) -> Tuple[float, float]:
    """
    Return the mouth position in *logical* coordinates.
    Args:
        pos: fish Position (logical).
        spr: fish Sprite (must have base_w/base_h, optional mouth_fx/mouth_fy).
        face_right:
            - If provided, use this facing.
            - If None and target_x is provided, infer facing by comparing target_x to fish center.
            - If still None, fall back to spr.faces_right.
        target_x:
            - Optional target x (logical). Used to infer facing if face_right is None.
    Mouth anchor uses per-sprite (mouth_fx, mouth_fy) in the 0..1 range and mirrors X when facing left.
    """
    fx = float(getattr(spr, "mouth_fx", 0.85))
    fy = float(getattr(spr, "mouth_fy", 0.50))
    if face_right is None:
        if target_x is not None:
            center_x = pos.x + spr.base_w * 0.5
            face_right = (target_x >= center_x)
        else:
            face_right = bool(getattr(spr, "faces_right", True))
    if not face_right:
        fx = 1.0 - fx
    mx = pos.x + spr.base_w * fx
    my = pos.y + spr.base_h * fy
    return mx, my
```
# === FILE END: utils\geometry.py ===
# === FILE START: utils\jsonio.py ===
```python
# [utils/jsonio.py] — safer loads with encoding + defaults + clear errors
import json, io
def load_json(path, default=None):
    try:
        with io.open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        if default is not None:
            print(f"⚠ JSON not found, using default for {path}")
            return default
        raise
    except json.JSONDecodeError as e:
        if default is not None:
            print(f"⚠ Bad JSON ({path}): {e}. Using default.")
            return default
        raise
def save_json(path, data):
    with io.open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)
def merge_with_defaults(data, defaults):
    out = defaults.copy()
    out.update(data or {})
    return out
```
# === FILE END: utils\jsonio.py ===
# === FILE START: utils\rng.py ===
```python
```
# === FILE END: utils\rng.py ===
# === FILE START: utils\spatial.py ===
```python
```
# === FILE END: utils\spatial.py ===
# === FILE START: utils\steering.py ===
```python
```
# === FILE END: utils\steering.py ===
# === FILE START: ecs\components\__init__.py ===
```python
# ecs/components/__init__.py
from dataclasses import dataclass
# Registry of component classes, so systems can refer to them easily
COMPONENTS = {}
def register_component(cls):
    """Decorator to auto-register component in ECS."""
    COMPONENTS[cls.__name__] = cls
    return cls
```
# === FILE END: ecs\components\__init__.py ===
# === FILE START: ecs\factories\__init__.py ===
```python
```
# === FILE END: ecs\factories\__init__.py ===
# === FILE START: ecs\factories\fish_factory.py ===
```python
"""
ecs/factories/fish_factory.py
Factory helpers for creating fish entities with sensible, slightly
personalized (jittered) stats and behavior tuning.
Notes
-----
- Numeric stats are jittered for variety:
  * "stable" keys get ±4% noise
  * everything else gets ±10% noise
- Species-provided "behavior" overrides are merged on top of defaults.
- This factory assumes `species_data` includes at least:
    - width (int), height (int), max_age (float/int)
    - sprite (optional; falls back to species_id)
"""
from __future__ import annotations
import random
from typing import Any, Dict
from ecs.components.core.position_component import Position
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.fish.motion_component import MotionParams
from ecs.components.core.velocity_component import Velocity
from ecs.components.fish.brain_component import Brain
from ecs.components.core.collider_component import Collider
from ecs.components.fish.age_component import Age
from ecs.components.fish.hunger_component import Hunger
from ecs.components.fish.health_component import Health
from ecs.components.fish.species_component import Species
from ecs.components.fish.behavior_tuning import BehaviorTuning
from ecs.components.fish.target_intent_component import TargetIntent
from ecs.components.fish.steering_intent_component import SteeringIntent
from ecs.components.fish.speed_intent_component import SpeedIntent
from ecs.components.fish.breeding_component import Breeding
# Keys that should vary less to keep movement feel consistent across runs.
_STABILITY_KEYS = {"speed", "acceleration", "turn_speed", "hunger_rate"}
def _jitter(value: Any, key: str) -> Any:
    """
    Return a jittered copy of numeric values; non-numerics are returned as-is.
    Stable keys get a small ±4% noise. All other numeric keys get ±10%.
    """
    if not isinstance(value, (int, float)):
        return value
    if key in _STABILITY_KEYS:
        span = 0.04
    else:
        span = 0.10
    return value * (1.0 + random.uniform(-span, span))
def create_fish(
    world,
    context,
    tank_entity: int,
    species_id: str,
    species_data: Dict[str, Any],
    x: float,
    y: float,
) -> int:
    """
    Create a fish entity with components and jittered stats.
    Parameters
    ----------
    world : World
        ECS world to mutate.
    context : GameContext
        Provides global defaults and configs (fish_defaults, etc.).
    tank_entity : int
        Entity id of the tank this fish belongs to.
    species_id : str
        Key/name of the species (used as fallback sprite id and display name).
    species_data : dict
        Species record (expects width, height, max_age, optional sprite, behavior).
    x, y : float
        Initial logical coordinates inside the tank.
    Returns
    -------
    int
        The newly created entity id.
    """
    # ---- Required species fields (fail fast with a clear error) -----------------
    try:
        base_w = int(species_data["width"])
        base_h = int(species_data["height"])
        max_age = float(species_data["max_age"])
    except KeyError as exc:
        missing = str(exc).strip("'")
        raise KeyError(
            f"species_data missing required key '{missing}' for species '{species_id}'"
        ) from exc
    # ---- Merge stats: defaults <- species_data (flat) ---------------------------
    # Start with global defaults, let species override them.
    defaults: Dict[str, Any] = (context.fish_defaults or {}).copy()
    merged_stats: Dict[str, Any] = defaults.copy()
    merged_stats.update(species_data)
    # ---- Merge behavior: start from the flattened stats-overrides --------------
    # We copy any keys that exist in defaults (to inherit global behavior fields),
    # then override with explicit species["behavior"] block if provided.
    species_behavior: Dict[str, Any] = species_data.get("behavior", {}) or {}
    merged_behavior: Dict[str, Any] = {
        k: merged_stats[k] for k in defaults.keys() if k in merged_stats
    }
    merged_behavior.update(species_behavior)
    # ---- Apply jitter for personal variation -----------------------------------
    merged_stats = {k: _jitter(v, k) for k, v in merged_stats.items()}
    merged_behavior = {k: _jitter(v, k) for k, v in merged_behavior.items()}
    # ---- Entity + core components ----------------------------------------------
    e = world.create_entity()
    world.add_component(e, TankRef(tank_entity))
    world.add_component(e, Position(x, y))
    sprite_name = species_data.get("sprite", species_id)
    world.add_component(
        e,
        Sprite(
            image_id=sprite_name,
            base_w=base_w,
            base_h=base_h,
            faces_right=bool(species_data.get("sprite_faces_right", True)),
        ),
    )
    world.add_component(
        e,
        MotionParams(
            max_speed=float(merged_stats["speed"]),
            acceleration=float(merged_stats["acceleration"]),
            turn_speed=float(merged_stats["turn_speed"]),
            dart_multiplier=float(merged_stats["dart_multiplier"]),
        ),
    )
    world.add_component(e, Velocity(0.0, 0.0))
    # Collider radius heuristic: ~40% of width tends to look reasonable.
    world.add_component(e, Collider(radius=base_w * 0.4))
    world.add_component(e, Age(age=0.0, lifespan=max_age))
    world.add_component(
        e,
        Hunger(
            hunger=float(merged_stats["hunger_max"]),
            hunger_rate=float(merged_stats["hunger_rate"]),
            hunger_max=float(merged_stats["hunger_max"]),
        ),
    )
    world.add_component(
        e,
        Health(
            value=float(merged_stats["health_max"]),
            max_value=float(merged_stats["health_max"]),
        ),
    )
    world.add_component(
        e,
        Species(
            species_id=species_id,
            display_name=species_id.title(),
            base_speed=float(merged_stats["speed"]),
        ),
    )
    world.add_component(e, Breeding())
    # Brain + behavior tuning
    brain = Brain(state="Cruise")
    world.add_component(e, brain)
    world.add_component(e, BehaviorTuning(merged_behavior))
    # Intent components (targets, steering and speed requests)
    world.add_component(e, TargetIntent())
    world.add_component(e, SteeringIntent())
    world.add_component(e, SpeedIntent())
    return e
```
# === FILE END: ecs\factories\fish_factory.py ===
# === FILE START: ecs\fsm\__init__.py ===
```python
# ecs/fsm/__init__.py
from ecs.fsm.idle_state import IdleState
from ecs.fsm.cruise_state import CruiseState
from ecs.fsm.dead_state import DeadState
from ecs.fsm.look_for_food_state import LookForFoodState
from ecs.fsm.chase_food_state import ChaseFoodState
from ecs.fsm.egg_state import EggState  # ← NEW
# Single registry
FSM_STATES = {
    IdleState.NAME: IdleState(),
    CruiseState.NAME: CruiseState(),
    DeadState.NAME: DeadState(),
    LookForFoodState.NAME: LookForFoodState(),
    ChaseFoodState.NAME: ChaseFoodState(),
    EggState.NAME: EggState(),  # ← NEW
}
```
# === FILE END: ecs\fsm\__init__.py ===
# === FILE START: ecs\fsm\base_state.py ===
```python
class BaseState:
    NAME = "Base"
    def enter(self, fish, context): pass
    def exit(self, fish, context): pass
    def update(self, fish, speed_intent, context, dt, world):
        raise NotImplementedError
    def set_target(self, fish, tx, ty):
        fish.brain.tx = tx; fish.brain.ty = ty
        fish.target.tx = tx; fish.target.ty = ty
```
# === FILE END: ecs\fsm\base_state.py ===
# === FILE START: ecs\fsm\chase_food_state.py ===
```python
from ecs.fsm.base_state import BaseState
from ecs.components.tags.food_pellet_component import FoodPellet
from ecs.components.core.position_component import Position
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.tank_ref_component import TankRef
from utils.geometry import get_mouth_logical
class ChaseFoodState(BaseState):
    NAME = "ChaseFood"
    @staticmethod
    def _pellet_center_and_radius(world, pellet_id):
        comps = getattr(world, "_components", {})
        if pellet_id not in comps: return None, None, None
        pos = world.get_component(pellet_id, Position)
        spr = world.get_component(pellet_id, Sprite)
        pellet = world.get_component(pellet_id, FoodPellet)
        if not pos or not spr or not pellet: return None, None, None
        cx = pos.x + spr.base_w * 0.5; cy = pos.y + spr.base_h * 0.5
        base_r = max(spr.base_w, spr.base_h) * 0.5
        pr = base_r * float(getattr(pellet, "radius_scale", 1.0))
        return cx, cy, pr
    @staticmethod
    def _mouth_radius(fish):
        factor = float(fish.tuning.get("mouth_radius_factor", 0.35))
        size = min(fish.sprite.base_w, fish.sprite.base_h)
        return max(4.0, size * factor * 0.5)
    @staticmethod
    def _nearest_pellet(world, from_x, from_y):
        nearest, best_d2 = None, None
        for pe in world.entities_with(FoodPellet, Position, Sprite, TankRef):
            ppos = world.get_component(pe, Position); pspr = world.get_component(pe, Sprite)
            cx = ppos.x + pspr.base_w * 0.5; cy = ppos.y + pspr.base_h * 0.5
            dx, dy = cx - from_x, cy - from_y
            d2 = dx*dx + dy*dy
            if best_d2 is None or d2 < best_d2: best_d2, nearest = d2, pe
        return nearest
    def enter(self, fish, context):
        b = fish.brain; t = fish.tuning
        b._speed_factor = float(t.get("chase_food_speed_factor", 1.0))
        b._target_pellet = None
    def update(self, fish, speed_intent, context, dt, world):
        b, t = fish.brain, fish.tuning
        fx = fish.pos.x + fish.sprite.base_w * 0.5
        fy = fish.pos.y + fish.sprite.base_h * 0.5
        target_pellet = self._nearest_pellet(world, fx, fy)
        if target_pellet is None:
            threshold = float(t.get("food_seek_threshold", 0.5))
            hungry = (fish.hunger.hunger / max(1e-6, fish.hunger.hunger_max)) < threshold
            return "LookForFood" if hungry else "Cruise"
        b._target_pellet = target_pellet
        pcx, pcy, pr = self._pellet_center_and_radius(world, target_pellet)
        if pcx is None:
            b._target_pellet = None; return None
        mx, my = get_mouth_logical(fish.pos, fish.sprite, target_x=pcx)
        mouth_r = self._mouth_radius(fish)
        eat_margin = float(t.get("eat_extra_margin", 6.0))
        self.set_target(fish, pcx, pcy)
        smooth = float(context.balancing.get("state_speed_smoothing", 0.10))
        target_speed = fish.motion.max_speed * b._speed_factor
        b.current_desired_speed += (target_speed - b.current_desired_speed) * smooth
        speed_intent.desired_speed = b.current_desired_speed
        dx, dy = pcx - mx, pcy - my
        dist = (dx*dx + dy*dy) ** 0.5
        if dist <= (pr + mouth_r + eat_margin):
            pellet = world.get_component(target_pellet, FoodPellet)
            nutrition = float(getattr(pellet, "nutrition", 40.0))
            audio = getattr(context, "audio", None)
            if audio:
                audio.play("bite")
            fish.hunger.hunger = min(fish.hunger.hunger_max, fish.hunger.hunger + nutrition)
            world.destroy_entity(target_pellet)
            b._target_pellet = None
            threshold = float(t.get("food_seek_threshold", 0.5))
            hungry = (fish.hunger.hunger / max(1e-6, fish.hunger.hunger_max)) < threshold
            return "LookForFood" if hungry else "Cruise"
        return None
```
# === FILE END: ecs\fsm\chase_food_state.py ===
# === FILE START: ecs\fsm\cruise_state.py ===
```python
import random
from math import hypot
from ecs.fsm.base_state import BaseState
class CruiseState(BaseState):
    NAME = "Cruise"
    def enter(self, fish, context):
        brain = fish.brain
        t = fish.tuning
        # Pull defaults from context.fish_defaults with safe fallbacks
        fd = getattr(context, "fish_defaults", {}) or {}
        cruise_min = t.get("cruise_min_time", fd.get("cruise_min_time", 6.0))
        cruise_max = t.get("cruise_max_time", fd.get("cruise_max_time", 16.0))
        arrival = t.get("cruise_arrival_radius", fd.get("cruise_arrival_radius", 40.0))
        speed_fac = t.get("cruise_speed_factor", fd.get("cruise_speed_factor", 0.6))
        leave_ch = t.get("transition_to_idle_chance", fd.get("transition_to_idle_chance", 0.01))
        brain.state_timer = 0.0
        brain._cruise_min = float(cruise_min)
        brain._cruise_max = float(cruise_max)
        brain._arrival = float(arrival)
        brain._speed_factor = float(speed_fac)
        brain._leave_chance = float(leave_ch)
        from random import uniform
        self.set_target(fish,
                        uniform(0, context.logical_tank_w),
                        uniform(0, context.logical_tank_h)
                        )
        brain.next_state_time = brain._cruise_min + uniform(0.0, 2.0)
    def update(self, fish, speed_intent, context, dt, world):
        b = fish.brain; pos = fish.pos
        if hypot(b.tx - pos.x, b.ty - pos.y) < b._arrival:
            self.set_target(fish,
                random.uniform(0, context.logical_tank_w),
                random.uniform(0, context.logical_tank_h)
            )
        smooth = float(context.balancing.get("state_speed_smoothing", 0.10))
        target_speed = fish.motion.max_speed * b._speed_factor
        b.current_desired_speed += (target_speed - b.current_desired_speed) * smooth
        speed_intent.desired_speed = b.current_desired_speed
        b.state_timer += dt
        if b.state_timer > b._cruise_max: return "Idle"
        if b.state_timer > b.next_state_time:
            import random as _r
            if _r.random() < b._leave_chance * _r.uniform(0.7, 1.3):
                return "Idle"
        return None
```
# === FILE END: ecs\fsm\cruise_state.py ===
# === FILE START: ecs\fsm\dead_state.py ===
```python
# ecs/fsm/dead_state.py
from ecs.fsm.base_state import BaseState
from ecs.components.tags.affected_by_gravity import AffectedByGravity
class DeadState(BaseState):
    NAME = "Dead"
    def enter(self, fish, context):
        brain = fish.brain
        brain.current_desired_speed = 0.0
        # Sink via gravity system instead of manual per-frame motion
        sink = float(context.balancing.get("dead_sink_speed", 30.0))
        # Add/update gravity component
        # (The system will handle resting on sand.)
        fish_entity = getattr(fish, "entity_id", None)
        world = getattr(fish, "world", None)
        # fish_view doesn’t keep entity/world by default; set via systems that call enter().
        # Safer approach: attach directly on known components via world if available.
        if world is not None and fish_entity is not None:
            world.add_component(fish_entity, AffectedByGravity(speed=sink))
        else:
            # Fallback: try to mutate through the view if it exposes world/add (some setups do)
            try:
                fish.add_component(AffectedByGravity(speed=sink))  # type: ignore[attr-defined]
            except Exception:
                pass
    def update(self, fish, speed_intent, context, dt, world):
        # Dead fish do not self-propel.
        speed_intent.desired_speed = 0.0
        # No manual sinking here; GravitySystem handles it.
        return None
```
# === FILE END: ecs\fsm\dead_state.py ===
# === FILE START: ecs\fsm\egg_state.py ===
```python
# ecs/fsm/egg_state.py
from ecs.fsm.base_state import BaseState
class EggState(BaseState):
    NAME = "Egg"
    def enter(self, fish, context):
        b = fish.brain
        b.current_desired_speed = 0.0
        # Sit still: keep target at current logical position
        self.set_target(fish, fish.pos.x, fish.pos.y)
    def update(self, fish, speed_intent, context, dt, world):
        # Eggs do not move/swim; GravitySystem handles falling.
        speed_intent.desired_speed = 0.0
        # Maintain target at current spot so steering stays neutral.
        self.set_target(fish, fish.pos.x, fish.pos.y)
        # No transition decision here — StateOverrideSystem handles leaving Egg
        # when Age.stage != "Egg".
        return None
```
# === FILE END: ecs\fsm\egg_state.py ===
# === FILE START: ecs\fsm\idle_state.py ===
```python
import random, math
from ecs.fsm.base_state import BaseState
class IdleState(BaseState):
    NAME = "Idle"
    def enter(self, fish, context):
        b = fish.brain; t = fish.tuning
        b.state_timer = 0.0
        b._min = t.get("idle_min_time"); b._max = t.get("idle_max_time")
        b._speed_factor = t.get("idle_speed_factor")
        b._amp = t.get("idle_bob_amplitude"); b._freq = t.get("idle_bob_frequency")
        b.idle_origin_x = fish.pos.x; b.idle_origin_y = fish.pos.y
        self._pick_new_idle_target(fish, context)
        b.next_state_time = b._min + random.uniform(0.0, 3.0)
    def _pick_new_idle_target(self, fish, context):
        b = fish.brain; amp = b._amp
        tx = max(0, min(context.logical_tank_w, b.idle_origin_x + random.uniform(-amp, amp)))
        ty = max(0, min(context.logical_tank_h, b.idle_origin_y + random.uniform(-amp, amp)))
        self.set_target(fish, tx, ty)
    def update(self, fish, speed_intent, context, dt, world):
        b = fish.brain; pos = fish.pos
        b.state_timer += dt
        amp, freq = b._amp, b._freq
        fx = float(context.balancing.get("idle_bob_x_factor", 1.0))
        fy = float(context.balancing.get("idle_bob_y_factor", 0.8))
        sx = math.sin(b.state_timer * freq) * (amp * 0.25) * fx
        sy = math.cos(b.state_timer * freq * 0.8) * (amp * 0.25) * fy
        self.set_target(fish, b.tx + sx, b.ty + sy)
        smooth = float(context.balancing.get("state_speed_smoothing", 0.10))
        target_speed = fish.motion.max_speed * b._speed_factor
        b.current_desired_speed += (target_speed - b.current_desired_speed) * smooth
        speed_intent.desired_speed = b.current_desired_speed
        if b.state_timer > b._max: return "Cruise"
        if b.state_timer > b.next_state_time:
            import random as _r
            if _r.random() < fish.tuning.get("transition_to_cruise_chance") * _r.uniform(0.7, 1.3):
                return "Cruise"
        return None
```
# === FILE END: ecs\fsm\idle_state.py ===
# === FILE START: ecs\fsm\look_for_food_state.py ===
```python
import random
from math import hypot
from ecs.fsm.base_state import BaseState
from ecs.components.tags.food_pellet_component import FoodPellet
from ecs.components.core.position_component import Position
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.tank_ref_component import TankRef
class LookForFoodState(BaseState):
    NAME = "LookForFood"
    def enter(self, fish, context):
        b = fish.brain; t = fish.tuning
        b.state_timer = 0.0
        b._speed_factor = float(t.get("look_for_food_speed_factor", 0.9))
        b._retarget_interval = 0.8; b._retarget_timer = 0.0
        b._target_pellet = None
        self.set_target(fish,
            random.uniform(0, context.logical_tank_w),
            random.uniform(0, context.logical_tank_h)
        )
    def _nearest_visible_pellet(self, world, fish_pos, fish_spr, radius):
        fx = fish_pos.x + fish_spr.base_w * 0.5; fy = fish_pos.y + fish_spr.base_h * 0.5
        nearest, best_d, best_cx, best_cy = None, float("inf"), None, None
        for e in world.entities_with(FoodPellet, Position, Sprite, TankRef):
            p = world.get_component(e, Position); s = world.get_component(e, Sprite)
            cx = p.x + s.base_w * 0.5; cy = p.y + s.base_h * 0.5
            pr = max(s.base_w, s.base_h) * 0.5
            d = hypot(cx - fx, cy - fy)
            if d <= radius + pr and d < best_d:
                nearest, best_d, best_cx, best_cy = e, d, cx, cy
        return nearest, best_cx, best_cy
    def update(self, fish, speed_intent, context, dt, world):
        b, pos, spr, t = fish.brain, fish.pos, fish.sprite, fish.tuning
        vision = float(t.get("food_detect_radius", 200.0))
        target_id, cx, cy = self._nearest_visible_pellet(world, pos, spr, vision)
        if target_id is not None:
            b._target_pellet = target_id
            b._target_pellet_cx = cx; b._target_pellet_cy = cy
            return "ChaseFood"
        b._retarget_timer += dt
        if b._retarget_timer >= b._retarget_interval:
            b._retarget_timer = 0.0
            self.set_target(fish,
                random.uniform(0, context.logical_tank_w),
                random.uniform(0, context.logical_tank_h)
            )
        smooth = float(context.balancing.get("state_speed_smoothing", 0.10))
        target_speed = fish.motion.max_speed * b._speed_factor
        b.current_desired_speed += (target_speed - b.current_desired_speed) * smooth
        speed_intent.desired_speed = b.current_desired_speed
        return None
```
# === FILE END: ecs\fsm\look_for_food_state.py ===
# === FILE START: ecs\systems\__init__.py ===
```python
```
# === FILE END: ecs\systems\__init__.py ===
# === FILE START: ecs\views\__init__.py ===
```python
```
# === FILE END: ecs\views\__init__.py ===
# === FILE START: ecs\views\fish_view.py ===
```python
from dataclasses import dataclass
from typing import Optional
from ecs.components.fish.brain_component import Brain
from ecs.components.core.position_component import Position
from ecs.components.core.velocity_component import Velocity
from ecs.components.fish.motion_component import MotionParams
from ecs.components.fish.hunger_component import Hunger
from ecs.components.core.sprite_component import Sprite
from ecs.components.fish.behavior_tuning import BehaviorTuning
from ecs.components.fish.target_intent_component import TargetIntent
from ecs.components.fish.steering_intent_component import SteeringIntent
from ecs.components.fish.speed_intent_component import SpeedIntent
@dataclass
class FishView:
    brain: Brain
    pos: Position
    vel: Optional[Velocity]
    motion: MotionParams
    hunger: Hunger
    sprite: Sprite
    tuning: BehaviorTuning
    target: TargetIntent
    steering: SteeringIntent
    speed: SpeedIntent
```
# === FILE END: ecs\views\fish_view.py ===
# === FILE START: ecs\components\core\__init__.py ===
```python
```
# === FILE END: ecs\components\core\__init__.py ===
# === FILE START: ecs\components\core\bounds_component.py ===
```python
from dataclasses import dataclass
@dataclass
class Bounds:
    width: int
    height: int
```
# === FILE END: ecs\components\core\bounds_component.py ===
# === FILE START: ecs\components\core\collider_component.py ===
```python
from dataclasses import dataclass
@dataclass
class Collider:
    radius: float
```
# === FILE END: ecs\components\core\collider_component.py ===
# === FILE START: ecs\components\core\position_component.py ===
```python
from dataclasses import dataclass
@dataclass
class Position:
    x: float
    y: float
```
# === FILE END: ecs\components\core\position_component.py ===
# === FILE START: ecs\components\core\sprite_component.py ===
```python
# ecs/components/sprite_component.py
from dataclasses import dataclass
@dataclass
class Sprite:
    image_id: str      # key to look up in AssetManager
    base_w: int        # logical/base width (e.g. species["width"])
    base_h: int        # logical/base height
    z: int = 1         # layer depth if needed later
    faces_right: bool = True  # base art faces right by default
    # Mouth anchor (fractions of sprite width/height).
    # When facing right, mouth is at (mouth_fx * base_w, mouth_fy * base_h).
    # When facing left, the X anchor is mirrored automatically in code.
    mouth_fx: float = 0.85
    mouth_fy: float = 0.50
```
# === FILE END: ecs\components\core\sprite_component.py ===
# === FILE START: ecs\components\core\tank_component.py ===
```python
# ecs/components/tank_component.py
from dataclasses import dataclass
@dataclass
class Tank:
    """Marker component to tag an entity as a tank."""
    pass
```
# === FILE END: ecs\components\core\tank_component.py ===
# === FILE START: ecs\components\core\tank_label_component.py ===
```python
# ecs/components/tank_label_component.py
from dataclasses import dataclass
@dataclass
class TankLabel:
    text: str = ""
    # Fallbacks; overridable from ui_config.json
    color: tuple = (255, 255, 255)
    size: int = 28
```
# === FILE END: ecs\components\core\tank_label_component.py ===
# === FILE START: ecs\components\core\tank_ref_component.py ===
```python
from dataclasses import dataclass
@dataclass
class TankRef:
    tank_entity: int
```
# === FILE END: ecs\components\core\tank_ref_component.py ===
# === FILE START: ecs\components\core\tank_stats.py ===
```python
from dataclasses import dataclass
@dataclass
class TankStats:
    temperature: float = 22.0
    cleanliness: float = 1.0
    capacity: int = 50
```
# === FILE END: ecs\components\core\tank_stats.py ===
# === FILE START: ecs\components\core\tank_style_component.py ===
```python
# ecs/components/tank_style_component.py
from dataclasses import dataclass
@dataclass
class TankStyle:
    border_color: tuple = (20, 40, 80)
    thickness: int = 6
    padding: int = 0  # if you want tank slightly inset from screen edges later
```
# === FILE END: ecs\components\core\tank_style_component.py ===
# === FILE START: ecs\components\core\velocity_component.py ===
```python
from dataclasses import dataclass
@dataclass
class Velocity:
    dx: float
    dy: float
    # --- Compatibility aliases (tests sometimes use vx/vy) ---
    @property
    def vx(self) -> float:            # why: keep old test API working
        return self.dx
    @vx.setter
    def vx(self, value: float) -> None:
        self.dx = float(value)
    @property
    def vy(self) -> float:
        return self.dy
    @vy.setter
    def vy(self, value: float) -> None:
        self.dy = float(value)
    def __iter__(self):
        yield self.dx
        yield self.dy
```
# === FILE END: ecs\components\core\velocity_component.py ===
# === FILE START: ecs\components\fish\__init__.py ===
```python
```
# === FILE END: ecs\components\fish\__init__.py ===
# === FILE START: ecs\components\fish\age_component.py ===
```python
# [ecs/components/age_component.py] — lifespan starts at hatch; egg has its own timer
from dataclasses import dataclass
@dataclass
class Age:
    # Age that counts toward lifespan (starts at 0 once hatched)
    age: float = 0.0
    lifespan: float = 400.0
    # Life stage: "Egg" (pre-hatch, not aging), then "Juvenile"/"Adult"/"Senior"
    # Default to "Juvenile" so existing fish spawn hatched and moving.
    stage: str = "Juvenile"
    # Time spent as an egg (seconds). Does NOT count toward lifespan.
    pre_hatch: float = 0.0
```
# === FILE END: ecs\components\fish\age_component.py ===
# === FILE START: ecs\components\fish\behavior_tuning.py ===
```python
from dataclasses import dataclass
from typing import Dict, Any
@dataclass
class BehaviorTuning:
    params: Dict[str, Any]
    def get(self, key, default=None):
        return self.params.get(key, default)
```
# === FILE END: ecs\components\fish\behavior_tuning.py ===
# === FILE START: ecs\components\fish\brain_component.py ===
```python
from dataclasses import dataclass
@dataclass
class Brain:
    state: str = "Cruise"     # current FSM state
    state_timer: float = 0.0  # time spent in the current state
    next_state_time: float = 0.0  # earliest time we MAY switch
    tx: float = 0.0           # target point
    ty: float = 0.0
    current_desired_speed: float = 0.0
```
# === FILE END: ecs\components\fish\brain_component.py ===
# === FILE START: ecs\components\fish\breeding_component.py ===
```python
from dataclasses import dataclass
from typing import Optional
@dataclass
class Breeding:
    wants_breed: bool = False
    partner_id: Optional[int] = None
    time_near: float = 0.0
    cooldown: float = 0.0
    toggle_on: bool = False   # per-fish UI toggle; default OFF
```
# === FILE END: ecs\components\fish\breeding_component.py ===
# === FILE START: ecs\components\fish\health_component.py ===
```python
from dataclasses import dataclass
@dataclass
class Health:
    value: float = 100.0
    max_value: float = 100.0
```
# === FILE END: ecs\components\fish\health_component.py ===
# === FILE START: ecs\components\fish\hunger_component.py ===
```python
from dataclasses import dataclass
@dataclass
class Hunger:
    hunger: float = 0.0
    hunger_rate: float = 0.02
    hunger_max: float = 100.0
```
# === FILE END: ecs\components\fish\hunger_component.py ===
# === FILE START: ecs\components\fish\motion_component.py ===
```python
from dataclasses import dataclass
@dataclass
class MotionParams:
    max_speed: float = 40.0
    acceleration: float = 30.0
    turn_speed: float = 3.0       # radians/sec or normalized
    dart_multiplier: float = 2.5  # for the Dart state
```
# === FILE END: ecs\components\fish\motion_component.py ===
# === FILE START: ecs\components\fish\species_component.py ===
```python
from dataclasses import dataclass
@dataclass
class Species:
    species_id: str
    display_name: str
    base_speed: float
```
# === FILE END: ecs\components\fish\species_component.py ===
# === FILE START: ecs\components\fish\speed_intent_component.py ===
```python
from dataclasses import dataclass
@dataclass
class SpeedIntent:
    desired_speed: float = 0.0
```
# === FILE END: ecs\components\fish\speed_intent_component.py ===
# === FILE START: ecs\components\fish\steering_intent_component.py ===
```python
from dataclasses import dataclass
@dataclass
class SteeringIntent:
    dx: float = 0.0
    dy: float = 0.0  # reset every frame by MovementSystem
```
# === FILE END: ecs\components\fish\steering_intent_component.py ===
# === FILE START: ecs\components\fish\target_intent_component.py ===
```python
from dataclasses import dataclass
@dataclass
class TargetIntent:
    tx: float = 0.0
    ty: float = 0.0
```
# === FILE END: ecs\components\fish\target_intent_component.py ===
# === FILE START: ecs\components\tags\__init__.py ===
```python
```
# === FILE END: ecs\components\tags\__init__.py ===
# === FILE START: ecs\components\tags\affected_by_gravity.py ===
```python
# ecs/components/affected_by_gravity.py
from dataclasses import dataclass
@dataclass
class AffectedByGravity:
    """Marks an entity that should fall vertically in logical space."""
    speed: float = 55.0  # logical px/sec (override per-entity as needed)
```
# === FILE END: ecs\components\tags\affected_by_gravity.py ===
# === FILE START: ecs\components\tags\comfort_component.py ===
```python
from dataclasses import dataclass
@dataclass
class Comfort:
    comfort: float = 100.0
    max_value: float = 100.0
```
# === FILE END: ecs\components\tags\comfort_component.py ===
# === FILE START: ecs\components\tags\dead_component.py ===
```python
from dataclasses import dataclass
@dataclass
class DeadFlag:
    """Marker component for fish that have died."""
    pass
```
# === FILE END: ecs\components\tags\dead_component.py ===
# === FILE START: ecs\components\tags\food_pellet_component.py ===
```python
# ecs/components/food_pellet_component.py
from dataclasses import dataclass
@dataclass
class FoodPellet:
    """
    Marks a falling food pellet and carries gameplay tuning attached to the pellet.
    - nutrition: fullness restored when eaten
    - radius_scale: multiplies the sprite's base radius for collision/vision
    - center_off_x/y: pixel offsets in *logical space* for visual/art centering
    """
    nutrition: float = 40.0
    radius_scale: float = 1.0
    center_off_x: float = 0.0
    center_off_y: float = 0.0
```
# === FILE END: ecs\components\tags\food_pellet_component.py ===
# === FILE START: ecs\systems\ai\__init__.py ===
```python
```
# === FILE END: ecs\systems\ai\__init__.py ===
# === FILE START: ecs\systems\ai\behavior_system.py ===
```python
# ecs/systems/behavior_system.py
"""
BehaviorSystem
--------------
Bridges ECS components into a lightweight `FishView` and drives the per-fish FSM.
Responsibilities
* Build (and reuse) a FishView for each entity that has the full set of required
  components for behavior.
* Call `enter()` the first frame an entity is observed in a given state.
* Call `update()` on the current state's handler to produce a *proposed* next state.
* Return a mapping {entity_id: next_state_name or None} for the transition system.
Notes
* This system does not mutate Brain.state directly — it only proposes transitions.
* A small cache of FishView objects avoids reallocations each frame.
"""
from __future__ import annotations
from typing import Dict, Optional, Tuple
from ecs.views.fish_view import FishView
from ecs.fsm import FSM_STATES
from ecs.components.fish.brain_component import Brain
from ecs.components.core.position_component import Position
from ecs.components.core.velocity_component import Velocity
from ecs.components.fish.motion_component import MotionParams
from ecs.components.fish.hunger_component import Hunger
from ecs.components.core.sprite_component import Sprite
from ecs.components.fish.behavior_tuning import BehaviorTuning
from ecs.components.fish.target_intent_component import TargetIntent
from ecs.components.fish.steering_intent_component import SteeringIntent
from ecs.components.fish.speed_intent_component import SpeedIntent
from ecs.components.core.tank_ref_component import TankRef
class BehaviorSystem:
    """
    Orchestrates FSM updates for all fish entities that have the required components.
    """
    # Components required for a fish to participate in behavior updates.
    _REQUIRED = (
        Brain, Position, MotionParams, Velocity, Hunger,
        BehaviorTuning, Sprite, TankRef, TargetIntent, SteeringIntent, SpeedIntent,
    )
    def __init__(self, context) -> None:
        self.context = context
        # entity_id -> FishView (reused/updated each frame)
        self._views: Dict[int, FishView] = {}
        # Tracks whether we've called enter() for (entity, state_name).
        # Using a set is slightly cheaper than a dict of booleans.
        self._entered: Dict[Tuple[int, str], bool] = {}
        # Cache FSM registry reference (micro-optimization on dict global).
        self._fsm = FSM_STATES
    # --------------------------------------------------------------------- #
    # Internal helpers
    # --------------------------------------------------------------------- #
    def _get_view(
        self,
        e: int,
        brain: Brain,
        pos: Position,
        vel: Velocity,
        motion: MotionParams,
        hunger: Hunger,
        sprite: Sprite,
        tuning: BehaviorTuning,
        target: TargetIntent,
        steering: SteeringIntent,
        speed: SpeedIntent,
    ) -> FishView:
        """
        Return a cached FishView for the entity, updating its references in-place.
        """
        view = self._views.get(e)
        if view is None:
            view = FishView(brain, pos, vel, motion, hunger, sprite, tuning, target, steering, speed)
            self._views[e] = view
            return view
        # Refresh references (no new allocations).
        view.brain = brain
        view.pos = pos
        view.vel = vel
        view.motion = motion
        view.hunger = hunger
        view.sprite = sprite
        view.tuning = tuning
        view.target = target
        view.steering = steering
        view.speed = speed
        return view
    def _ensure_enter_called(self, e: int, brain: Brain, view: FishView) -> None:
        """
        Call enter() exactly once per (entity, state_name).
        """
        key = (e, brain.state)
        if key not in self._entered:
            self._fsm[brain.state].enter(view, self.context)
            self._entered[key] = True
    # --------------------------------------------------------------------- #
    # ECS system API
    # --------------------------------------------------------------------- #
    def update(self, world, dt: float) -> Dict[int, Optional[str]]:
        """
        Build FishViews, ensure state `enter()` is called, then invoke the state's
        `update()` to compute proposed next states.
        Returns
        -------
        Dict[entity_id, next_state or None]
        """
        proposed: Dict[int, Optional[str]] = {}
        fsm = self._fsm  # local ref
        # Iterate only over entities that have all required components.
        for e in world.entities_with(*self._REQUIRED):
            # Pull components once each (local vars are faster & clearer).
            brain: Brain = world.get_component(e, Brain)
            pos: Position = world.get_component(e, Position)
            vel: Velocity = world.get_component(e, Velocity)
            motion: MotionParams = world.get_component(e, MotionParams)
            hunger: Hunger = world.get_component(e, Hunger)
            sprite: Sprite = world.get_component(e, Sprite)
            tuning: BehaviorTuning = world.get_component(e, BehaviorTuning)
            target: TargetIntent = world.get_component(e, TargetIntent)
            steer: SteeringIntent = world.get_component(e, SteeringIntent)
            speed: SpeedIntent = world.get_component(e, SpeedIntent)
            # Compose (or refresh) the lightweight view.
            view = self._get_view(e, brain, pos, vel, motion, hunger, sprite, tuning, target, steer, speed)
            # Make entity/world available to state handlers (e.g., DeadState.enter)
            setattr(view, "entity_id", e)
            setattr(view, "world", world)
            # Ensure we called enter() for the current state at least once.
            self._ensure_enter_called(e, brain, view)
            # Run the state's update; it may return a next-state string or None.
            next_state = fsm[brain.state].update(view, speed, self.context, dt, world)
            proposed[e] = next_state
        return proposed
```
# === FILE END: ecs\systems\ai\behavior_system.py ===
# === FILE START: ecs\systems\ai\state_override_system.py ===
```python
# ecs/systems/state_override_system.py
from ecs.components.fish.hunger_component import Hunger
from ecs.components.fish.behavior_tuning import BehaviorTuning
from ecs.components.fish.brain_component import Brain
from ecs.components.tags.dead_component import DeadFlag
from ecs.components.fish.age_component import Age
class StateOverrideSystem:
    """
    Global guardrails / hard overrides for FSM transitions.
    Priority (high → low):
      1) Death: DeadFlag forces/keeps "Dead".
      2) Egg:   Age.stage == 'Egg' forces/keeps "Egg". When it stops being 'Egg',
                push to 'Idle' once to start normal behavior.
      3) Hunger bias: If very hungry, nudge to LookForFood (unless already food-related).
    """
    def update(self, world, proposed_states):
        # ----- 1) Hard override: DeadFlag → "Dead" -----
        dead_entities = set()
        for e in list(proposed_states.keys()):
            brain = world.get_component(e, Brain)
            if brain is None:
                continue
            if world.get_component(e, DeadFlag):
                dead_entities.add(e)
                if brain.state != "Dead":
                    proposed_states[e] = "Dead"
                else:
                    proposed_states[e] = None  # stay
        # ----- 2) Egg lock + exit-on-hatch -----
        for e in list(proposed_states.keys()):
            if e in dead_entities:
                continue
            brain = world.get_component(e, Brain)
            age = world.get_component(e, Age)
            if brain is None or age is None:
                continue
            if age.stage == "Egg":
                # Force/keep Egg state while it's an egg.
                if brain.state != "Egg":
                    proposed_states[e] = "Egg"
                else:
                    proposed_states[e] = None  # keep it there
                continue
            # Just hatched: if currently in Egg, move to Idle once.
            if brain.state == "Egg":
                proposed_states[e] = "Idle"
        # ----- 3) Hunger bias (skip dead or egg) -----
        for e, proposed in list(proposed_states.items()):
            if e in dead_entities:
                continue
            brain = world.get_component(e, Brain)
            age = world.get_component(e, Age)
            if brain is None or (age is not None and age.stage == "Egg") or brain.state == "Dead":
                continue
            hunger = world.get_component(e, Hunger)
            tuning = world.get_component(e, BehaviorTuning)
            if not (hunger and tuning):
                continue
            threshold = float(tuning.get("food_seek_threshold", 0.5))
            ratio = hunger.hunger / max(1e-6, hunger.hunger_max)
            if ratio < threshold:
                if (proposed not in ("ChaseFood", "LookForFood")
                        and brain.state not in ("ChaseFood", "LookForFood")):
                    proposed_states[e] = "LookForFood"
        return proposed_states
```
# === FILE END: ecs\systems\ai\state_override_system.py ===
# === FILE START: ecs\systems\ai\state_transition_system.py ===
```python
from ecs.fsm import FSM_STATES
from ecs.components.fish.brain_component import Brain
class StateTransitionSystem:
    def __init__(self, context, behavior_system):
        self.context = context
        self.behavior = behavior_system
        self._entered = {}
    def update(self, world, final_states, dt):
        for e, next_state in final_states.items():
            if next_state is None:
                continue
            brain = world.get_component(e, Brain)
            if brain is None:
                continue
            current = brain.state
            if next_state == current:
                continue
            fish_view = self.behavior._views.get(e)
            if fish_view is None:
                continue
            # EXIT old state
            if (e, current) in self._entered:
                FSM_STATES[current].exit(fish_view, self.context)
                self._entered.pop((e, current), None)
            # 🔊 if we're transitioning to Dead, play SFX once here
            if next_state == "Dead":
                audio = getattr(self.context, "audio", None)
                if audio:
                    audio.play("death")
            # SWITCH
            brain.state = next_state
            brain.state_timer = 0.0
            # ENTER new state
            FSM_STATES[next_state].enter(fish_view, self.context)
            self._entered[(e, next_state)] = True
```
# === FILE END: ecs\systems\ai\state_transition_system.py ===
# === FILE START: ecs\systems\core\__init__.py ===
```python
```
# === FILE END: ecs\systems\core\__init__.py ===
# === FILE START: ecs\systems\core\avoidance_system.py ===
```python
from math import hypot
from ecs.components.core.position_component import Position
from ecs.components.core.velocity_component import Velocity
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.fish.steering_intent_component import SteeringIntent
from math import hypot
from ecs.components.core.position_component import Position
from ecs.components.core.velocity_component import Velocity
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.fish.steering_intent_component import SteeringIntent
class AvoidanceSystem:
    def __init__(self, context):
        self.context = context
        b = context.balancing or {}
        # Width of the "avoid bands" hugging the walls (in logical px).
        self.margin = float(b.get("avoidance_margin", 20.0))
        # Max magnitude we allow for the avoidance steering contribution.
        self.max_strength = float(b.get("avoidance_max_strength", 0.25))
        # Reference speed used to scale avoidance with current speed.
        self._speed_ref = float(b.get("typical_max_speed", 40.0))
    def update(self, world, dt):
        # Logical tank size
        w = float(self.context.logical_tank_w)
        h = float(self.context.logical_tank_h)
        m = float(self.margin)
        # Where the *swimmable* water ends at the bottom.
        # This is the top edge of the dark brown frame in the background.
        swim_bottom_margin = float(getattr(self.context, "swim_bottom_margin", 64.0))
        water_bottom = h - swim_bottom_margin  # y coordinate in logical space
        for e in world.entities_with(Position, SteeringIntent, TankRef, Velocity):
            pos: Position = world.get_component(e, Position)
            intent: SteeringIntent = world.get_component(e, SteeringIntent)
            vel: Velocity = world.get_component(e, Velocity)
            # Normalize velocity to get a directional bias; if nearly stopped,
            # avoidance is minimal.
            speed = hypot(vel.dx, vel.dy)
            if speed < 1e-3:
                continue
            vx = vel.dx / speed
            vy = vel.dy / speed
            ax = 0.0  # avoidance steering x
            ay = 0.0  # avoidance steering y
            # ---- Left wall band ----
            if pos.x < m:
                # Push to the right; strength grows as we get closer to 0.
                # Use max(0, -vx) so we push more when currently heading *into* the wall.
                ax += (1.0 - (pos.x / m)) * max(0.0, -vx)
            # ---- Right wall band ----
            if pos.x > w - m:
                # Push to the left; strength grows as we get closer to w.
                ax -= (1.0 - ((w - pos.x) / m)) * max(0.0, vx)
            # ---- Top wall band ----
            if pos.y < m:
                # Push downward.
                ay += (1.0 - (pos.y / m)) * max(0.0, -vy)
            # ---- Bottom swim floor band (NOT the tank bottom) ----
            # Keep fish above the water_bottom line (top of dark brown frame).
            if pos.y > water_bottom - m:
                # Push upward; strength grows as we approach water_bottom.
                # Use the current downward component (vy>0) to bias more when heading down.
                ay -= (1.0 - ((water_bottom - pos.y) / m)) * max(0.0, vy)
            # Scale avoidance with speed so gentle drifters don’t overreact,
            # and sprinters get stronger correction.
            speed_scale = min(1.0, speed / self._speed_ref)
            ax *= speed_scale
            ay *= speed_scale
            # Clamp vector to the configured maximum strength.
            strength = hypot(ax, ay)
            if strength > self.max_strength and strength > 1e-7:
                s = self.max_strength / strength
                ax *= s
                ay *= s
            # Accumulate into the per-fish steering intent (MovementSystem will consume it).
            intent.dx += ax
            intent.dy += ay
```
# === FILE END: ecs\systems\core\avoidance_system.py ===
# === FILE START: ecs\systems\core\collision_system.py ===
```python
# ecs/systems/collision_system.py
from ecs.components.core.position_component import Position
from ecs.components.core.velocity_component import Velocity
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.tags.dead_component import DeadFlag
class CollisionSystem:
    """
    Enforces hard tank boundaries and applies bounce to velocity when colliding.
    MovementSystem no longer does any clamping/bounce; it only integrates.
    """
    def __init__(self, context):
        self.context = context
        self.wall_bounce = float((context.balancing or {}).get("wall_bounce", 0.35))
    def update(self, world, dt):
        lw = self.context.logical_tank_w
        lh = self.context.logical_tank_h
        swim_floor = float(getattr(self.context, "swim_bottom_margin", 64))
        alive_bottom_y = lh - swim_floor  # top of dark brown frame
        for e in world.entities_with(Position, Velocity, Sprite, TankRef):
            if world.get_component(e, DeadFlag):
                # dead: keep existing full-tank clamp (GravitySystem settles them on sand)
                pos = world.get_component(e, Position)
                spr = world.get_component(e, Sprite)
                if pos.x < 0: pos.x = 0
                if pos.x + spr.base_w > lw: pos.x = lw - spr.base_w
                if pos.y < 0: pos.y = 0
                if pos.y + spr.base_h > lh: pos.y = lh - spr.base_h
                continue
            pos = world.get_component(e, Position)
            vel = world.get_component(e, Velocity)
            spr = world.get_component(e, Sprite)
            # left/right/top (unchanged) ...
            if pos.x < 0.0:
                pos.x = 0.0
                if vel.dx < 0.0: vel.dx = -vel.dx * self.wall_bounce
            if pos.x + spr.base_w > lw:
                pos.x = lw - spr.base_w
                if vel.dx > 0.0: vel.dx = -vel.dx * self.wall_bounce
            if pos.y < 0.0:
                pos.y = 0.0
                if vel.dy < 0.0: vel.dy = -vel.dy * self.wall_bounce
            # bottom → clamp to the swim floor (not the tank bottom)
            bottom_limit = max(0.0, alive_bottom_y - spr.base_h)
            if pos.y > bottom_limit:
                pos.y = bottom_limit
                if vel.dy > 0.0:
                    vel.dy = -vel.dy * self.wall_bounce
```
# === FILE END: ecs\systems\core\collision_system.py ===
# === FILE START: ecs\systems\core\movement_system.py ===
```python
from math import hypot, atan2, cos, sin
import random
from ecs.components.fish.motion_component import MotionParams
from ecs.components.core.position_component import Position
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.core.velocity_component import Velocity
from ecs.components.fish.behavior_tuning import BehaviorTuning
from ecs.components.core.sprite_component import Sprite
from ecs.components.tags.dead_component import DeadFlag
from ecs.components.fish.target_intent_component import TargetIntent
from ecs.components.fish.steering_intent_component import SteeringIntent
from ecs.components.fish.speed_intent_component import SpeedIntent
def _clamp_angle(delta, limit):
    if delta > limit: return limit
    if delta < -limit: return -limit
    return delta
class MovementSystem:
    """
    Integrates desired motion:
      - Builds direction from target + steering (AvoidanceSystem)
      - Applies turning limit and acceleration clamp
      - Applies damping
      - Integrates pos/vel
    NOTE: No boundary checks or bounce here — CollisionSystem handles that.
    """
    def __init__(self, context):
        self.context = context
        b = context.balancing
        self.damping = float(b.get("movement_damping", 0.94))
    def update(self, world, dt: float):
        for e in world.entities_with(
            Position, Velocity, MotionParams,
            TargetIntent, SteeringIntent, SpeedIntent, TankRef, Sprite
        ):
            if world.get_component(e, DeadFlag):
                continue
            pos = world.get_component(e, Position)
            vel = world.get_component(e, Velocity)
            motion = world.get_component(e, MotionParams)
            target = world.get_component(e, TargetIntent)
            steer  = world.get_component(e, SteeringIntent)
            speedi = world.get_component(e, SpeedIntent)
            spr    = world.get_component(e, Sprite)
            # Direction toward target + soft steering (already set by AvoidanceSystem)
            dx = target.tx - pos.x; dy = target.ty - pos.y
            dist = max(1e-6, hypot(dx, dy))
            base_dx, base_dy = dx / dist, dy / dist
            dir_x = base_dx + steer.dx; dir_y = base_dy + steer.dy
            # Optional behavioral noise
            tuning = world.get_component(e, BehaviorTuning)
            if tuning:
                noise = float(tuning.get("noise", 0.0))
                if noise > 0.0:
                    dir_x += random.uniform(-noise, noise)
                    dir_y += random.uniform(-noise, noise)
            # Normalize final dir
            dlen = hypot(dir_x, dir_y)
            if dlen > 1e-5:
                dir_x /= dlen; dir_y /= dlen
            # Speed target
            desired_speed = max(0.0, min(speedi.desired_speed, motion.max_speed))
            des_vx, des_vy = dir_x * desired_speed, dir_y * desired_speed
            # Heading turn limit
            cur_speed = hypot(vel.dx, vel.dy)
            if cur_speed < 1e-6:
                heading_vx, heading_vy = dir_x, dir_y
            else:
                cur_ang = atan2(vel.dy, vel.dx)
                des_ang = atan2(des_vy, des_vx) if desired_speed > 1e-6 else cur_ang
                da = (des_ang - cur_ang + 3.14159265) % (2*3.14159265) - 3.14159265
                max_rotate = max(0.0, motion.turn_speed) * dt
                cur_ang += _clamp_angle(da, max_rotate)
                heading_vx, heading_vy = cos(cur_ang), sin(cur_ang)
            # Accel clamp toward target velocity
            target_vx, target_vy = heading_vx * desired_speed, heading_vy * desired_speed
            dvx, dvy = target_vx - vel.dx, target_vy - vel.dy
            dv_len = hypot(dvx, dvy); max_delta = motion.acceleration * dt
            if dv_len > max_delta and dv_len > 1e-6:
                s = max_delta / dv_len; dvx *= s; dvy *= s
            # Apply velocity & damping
            vel.dx = (vel.dx + dvx) * self.damping
            vel.dy = (vel.dy + dvy) * self.damping
            # Integrate position (no clamping here)
            pos.x += vel.dx * dt
            pos.y += vel.dy * dt
            # Reset steering each frame
            steer.dx = 0.0; steer.dy = 0.0
```
# === FILE END: ecs\systems\core\movement_system.py ===
# === FILE START: ecs\systems\core\resize_system.py ===
```python
# ecs/systems/resize_system.py
from ecs.components.core.bounds_component import Bounds
from ecs.components.core.position_component import Position
from ecs.components.core.tank_component import Tank
class ResizeSystem:
    """
    Handles resizing the tank whenever the window is resized.
    - Uses logical tank size stored in context (logical_tank_w/h)
    - Computes new scale so the tank fits inside the screen
    - Updates tank entity position + size in screen space
    - Stores tank screen rect + scale on context
    """
    def __init__(self, context):
        self.context = context
    def update(self, world, dt):
        # Only do work when a resize was requested
        if not self.context.needs_resize:
            return
        new_w = self.context.new_screen_w
        new_h = self.context.new_screen_h
        logical_w = self.context.logical_tank_w
        logical_h = self.context.logical_tank_h
        # --- Compute scale so logical tank fits inside the window ---
        scale = min(new_w / logical_w, new_h / logical_h)
        self.context.tank_scale = scale
        tank_render_w = int(logical_w * scale)
        tank_render_h = int(logical_h * scale)
        # Center tank on screen
        tank_x = (new_w - tank_render_w) // 2
        tank_y = (new_h - tank_render_h) // 2
        # Store for anyone else who cares
        self.context.tank_screen_x = tank_x
        self.context.tank_screen_y = tank_y
        self.context.tank_screen_w = tank_render_w
        self.context.tank_screen_h = tank_render_h
        # --- Update the actual tank entity ---
        for tank in world.entities_with(Tank, Position, Bounds):
            pos = world.get_component(tank, Position)
            bounds = world.get_component(tank, Bounds)
            pos.x = tank_x
            pos.y = tank_y
            bounds.width = tank_render_w
            bounds.height = tank_render_h
        # Done for this resize event
        self.context.needs_resize = False
```
# === FILE END: ecs\systems\core\resize_system.py ===
# === FILE START: ecs\systems\gameplay\__init__.py ===
```python
```
# === FILE END: ecs\systems\gameplay\__init__.py ===
# === FILE START: ecs\systems\gameplay\aging_system.py ===
```python
# ecs/systems/aging_system.py
from ecs.components.fish.age_component import Age
from ecs.components.fish.motion_component import MotionParams
from ecs.components.fish.health_component import Health
from ecs.components.tags.dead_component import DeadFlag
from ecs.components.tags.affected_by_gravity import AffectedByGravity  # used to drop eggs
# NOTE: Do not assign to names like DeadFlag inside functions; we only import & use them.
class AgingSystem:
    """
    - Eggs: accumulate pre-hatch time; lifespan/aging begin at hatching (age=0).
    - Post-hatch: juvenile/adult/senior speed scaling and elder health decay.
    - Optional hard death at lifespan.
    Config (data/aging.json):
      - elder_threshold_ratio
      - juvenile_threshold_ratio
      - elder_speed_multiplier_min
      - juvenile_speed_multiplier_min
      - elder_health_decay_at_max_per_sec
      - hard_death_at_lifespan
      - egg_duration_sec (preferred)
      - egg_threshold_ratio (fallback if no seconds set)
    """
    def __init__(self, context):
        self.context = context
        cfg = context.aging or {}
        # Stage thresholds (post-hatch age/lifespan ratios)
        self.r_elder = float(cfg.get("elder_threshold_ratio", 0.80))
        self.r_juv   = float(cfg.get("juvenile_threshold_ratio", 0.15))
        # Speed multipliers (ramps)
        self.min_elder = float(cfg.get("elder_speed_multiplier_min", 0.70))
        self.min_juv   = float(cfg.get("juvenile_speed_multiplier_min", 0.85))
        # Elder decay & hard death
        self.elder_hdecay = float(cfg.get("elder_health_decay_at_max_per_sec", 0.04))
        self.hard_death   = bool(cfg.get("hard_death_at_lifespan", True))
        # Egg timing
        self.egg_duration_sec_cfg = cfg.get("egg_duration_sec", None)
        self.egg_ratio_cfg = cfg.get("egg_threshold_ratio", None)
    # ---- helpers -------------------------------------------------------------
    def _egg_hatch_seconds(self, lifespan: float) -> float:
        # Prefer absolute seconds
        val = self.egg_duration_sec_cfg
        if val is not None:
            try:
                return max(0.0, float(val))
            except Exception:
                pass
        # Fallback: ratio of lifespan
        r = self.egg_ratio_cfg
        if r is not None:
            try:
                r = max(0.0, min(1.0, float(r)))
                return max(0.0, lifespan * r)
            except Exception:
                pass
        # Default if no config given
        return 8.0
    def _speed_mult_for_ratio(self, r: float) -> float:
        # Juvenile ramp: [0 .. r_juv] => min_juv → 1
        if r <= self.r_juv:
            if self.r_juv <= 1e-6:
                return 1.0
            t = max(0.0, min(1.0, r / self.r_juv))
            return self.min_juv + (1.0 - self.min_juv) * t
        # Elder ramp: [r_elder .. 1] => 1 → min_elder
        if r >= self.r_elder:
            span = max(1e-6, (1.0 - self.r_elder))
            t = max(0.0, min(1.0, (r - self.r_elder) / span))
            return 1.0 + (self.min_elder - 1.0) * t
        # Adult
        return 1.0
    def _elder_health_decay_per_sec(self, r: float, health_max: float) -> float:
        if r < self.r_elder or self.elder_hdecay <= 0.0:
            return 0.0
        span = max(1e-6, (1.0 - self.r_elder))
        t = (r - self.r_elder) / span  # 0..1
        return health_max * (self.elder_hdecay * t)
    def _update_stage_from_ratio(self, age_cmp: Age, ratio: float) -> None:
        if ratio < self.r_juv:
            stage = "Juvenile"
        elif ratio >= self.r_elder:
            stage = "Senior"
        else:
            stage = "Adult"
        if age_cmp.stage != stage:
            age_cmp.stage = stage
    # ---- ECS entry -----------------------------------------------------------
    def update(self, world, dt: float):
        if dt <= 0.0:
            return
        for e in world.entities_with(Age):
            # Skip dead — DeadState/Gravity handles their presentation/motion.
            if world.get_component(e, DeadFlag):
                continue
            age = world.get_component(e, Age)
            # EGG PHASE: accumulate pre-hatch; no lifespan aging yet
            if age.stage == "Egg":
                age.pre_hatch += dt
                # Ensure eggs fall if GravitySystem is in use
                if world.get_component(e, AffectedByGravity) is None:
                    world.add_component(e, AffectedByGravity(speed=float(
                        (self.context.balancing or {}).get("egg_fall_speed", 55.0)
                    )))
                hatch_after = self._egg_hatch_seconds(age.lifespan)
                if age.pre_hatch >= hatch_after:
                    # Hatch now → start real aging from 0
                    age.stage = "Juvenile"
                    age.age = 0.0
                    # Remove gravity so the fish can swim normally
                    world.remove_component(e, AffectedByGravity)
                continue  # nothing else while egg
            # POST-HATCH: advance age & compute ratio
            age.age += dt
            ratio = max(0.0, age.age / max(1e-6, age.lifespan))
            # Stage label
            self._update_stage_from_ratio(age, ratio)
            # Speed scaling by life stage
            mp = world.get_component(e, MotionParams)
            if mp is not None:
                if not hasattr(mp, "base_max_speed"):
                    mp.base_max_speed = float(mp.max_speed)
                mp.max_speed = mp.base_max_speed * self._speed_mult_for_ratio(ratio)
            # Elder health decay
            h = world.get_component(e, Health)
            if h is not None:
                h.value -= self._elder_health_decay_per_sec(ratio, h.max_value) * dt
                if h.value < 0:
                    h.value = 0
            # Optional hard death at lifespan
            if self.hard_death and age.age >= age.lifespan:
                if not world.get_component(e, DeadFlag):
                    world.add_component(e, DeadFlag())
                # NEW: make the biological stage reflect death
                age.stage = "Dead"
```
# === FILE END: ecs\systems\gameplay\aging_system.py ===
# === FILE START: ecs\systems\gameplay\health_system.py ===
```python
# ecs/systems/health_system.py
from ecs.components.fish.health_component import Health
from ecs.components.fish.hunger_component import Hunger
from ecs.components.fish.behavior_tuning import BehaviorTuning
from ecs.components.tags.dead_component import DeadFlag
from ecs.components.fish.age_component import Age
class HealthSystem:
    """
    Handles health regeneration and starvation.
    Does NOT change AI state directly — sets DeadFlag instead.
    """
    def update(self, world, dt):
        for e in world.entities_with(Health, Hunger, BehaviorTuning):
            if world.get_component(e, DeadFlag):
                continue
            health = world.get_component(e, Health)
            hunger = world.get_component(e, Hunger)
            tuning = world.get_component(e, BehaviorTuning)
            regen_factor = tuning.get("health_regen_factor", 0.0)
            starve_factor = tuning.get("health_starve_factor", 0.0)
            regen_threshold = tuning.get("health_regen_threshold", 0.5)
            hunger_ratio = hunger.hunger / hunger.hunger_max
            # Regeneration
            if hunger_ratio > regen_threshold:
                health.value = min(
                    health.max_value,
                    health.value + health.max_value * regen_factor * dt
                )
            # Starvation damage
            if hunger.hunger <= 0:
                health.value -= health.max_value * starve_factor * dt
            # Mark death (but do not change AI state!)
            if health.value <= 0:
                if not world.get_component(e, DeadFlag):
                    world.add_component(e, DeadFlag())
                # NEW: reflect death in the life-stage component
                age = world.get_component(e, Age)
                if age is not None:
                    age.stage = "Dead"
```
# === FILE END: ecs\systems\gameplay\health_system.py ===
# === FILE START: ecs\systems\gameplay\hunger_system.py ===
```python
# ecs/systems/hunger_system.py
from ecs.components.fish.hunger_component import Hunger
from ecs.components.fish.health_component import Health
from ecs.components.tags.dead_component import DeadFlag
class HungerSystem:
    """
    Per-fish hunger decay.
    Each fish has:
        hunger.hunger       (0 .. hunger_max)
        hunger.hunger_rate  (per second)
        hunger.hunger_max   (species or default)
    When hunger hits 0 → health drains in HealthSystem, not here.
    """
    def update(self, world, dt):
        for e in world.entities_with(Hunger, Health):
            if world.get_component(e, DeadFlag):
                continue
            hunger = world.get_component(e, Hunger)
            # Reduce hunger
            hunger.hunger -= hunger.hunger_rate * dt
            # Clamp
            if hunger.hunger < 0:
                hunger.hunger = 0
            if hunger.hunger > hunger.hunger_max:
                hunger.hunger = hunger.hunger_max
```
# === FILE END: ecs\systems\gameplay\hunger_system.py ===
# === FILE START: ecs\systems\gameplay\population_guard.py ===
```python
from ecs.components.fish.brain_component import Brain
from ecs.components.tags.dead_component import DeadFlag
class PopulationGuard:
    """
    Maintains ctx.population_ok by counting living (Brain & !DeadFlag).
    Why: gate breeding completion and eligibility.
    """
    def __init__(self, context):
        self.ctx = context
    def update(self, world, dt):
        living = 0
        for e in world.entities_with(Brain):
            if world.get_component(e, DeadFlag) is None:
                living += 1
        self.ctx.population_ok = (living < int(self.ctx.breeding["max_population"]))
```
# === FILE END: ecs\systems\gameplay\population_guard.py ===
# === FILE START: ecs\systems\physics\__init__.py ===
```python
```
# === FILE END: ecs\systems\physics\__init__.py ===
# === FILE START: ecs\systems\physics\gravity_system.py ===
```python
# ecs/systems/gravity_system.py
from ecs.components.tags.affected_by_gravity import AffectedByGravity
from ecs.components.core.position_component import Position
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.tank_ref_component import TankRef
class GravitySystem:
    """
    Single, generic falling system for pellets, eggs, dead fish, etc.
    Applies +Y based on AffectedByGravity.speed until resting on the sand.
    """
    def __init__(self, context):
        self.context = context
    def _floor_logical_y(self) -> float:
        """Top of sand in logical coords."""
        logical_h = self.context.logical_tank_h
        px = getattr(self.context, "sand_top_px", -1)
        if px is not None and px >= 0:
            return min(logical_h, float(px))
        r = float(getattr(self.context, "sand_top_ratio", 1.0))
        return logical_h * max(0.0, min(1.0, r))
    def update(self, world, dt: float) -> None:
        if dt <= 0.0:
            return
        floor_y = self._floor_logical_y()
        for e in world.entities_with(AffectedByGravity, Position, Sprite, TankRef):
            grav = world.get_component(e, AffectedByGravity)
            pos = world.get_component(e, Position)
            spr = world.get_component(e, Sprite)
            pos.y += float(grav.speed) * dt
            rest_y = floor_y - spr.base_h
            if pos.y > rest_y:
                pos.y = rest_y
```
# === FILE END: ecs\systems\physics\gravity_system.py ===
# === FILE START: ecs\systems\renderers\__init__.py ===
```python
# ecs/systems/renderers/__init__.py
"""
Convenience re-exports for renderer helpers and caches.
"""
from .cache import LabelCache, SpriteCache
from .geometry import (
    center_logical,
    pellet_center_radius,
    mouth_logical,
    mouth_radius_from_tuning,
    vision_radius_from_tuning,
)
from .draw_sprite import choose_facing, draw_sprite
from .overlay_labels import draw_state_and_bars
from .overlay_food import draw_food_debug, draw_target_line_from_mouth
from .overlay_motion import draw_velocity_arrow, draw_avoidance_arrow
__all__ = [
    "LabelCache",
    "SpriteCache",
    "center_logical",
    "pellet_center_radius",
    "mouth_logical",
    "mouth_radius_from_tuning",
    "vision_radius_from_tuning",
    "choose_facing",
    "draw_sprite",
    "draw_state_and_bars",
    "draw_food_debug",
    "draw_target_line_from_mouth",
    "draw_velocity_arrow",
    "draw_avoidance_arrow",
]
```
# === FILE END: ecs\systems\renderers\__init__.py ===
# === FILE START: ecs\systems\renderers\cache.py ===
```python
# ecs/systems/renderers/cache.py
"""
Lightweight sprite/label surface caches with optional variants:
- dead=True: grayscale + vertical flip (your existing "Dead" look)
- hflip=True: horizontal flip (ignored when dead=True)
- variant="senior": partial desaturate + warm tint (+ optional 1px outline)
All heavy pixel work happens once per unique cache key.
This version also publishes the final, already-transformed surface that the
sprite renderer blitted for each entity so the Fish window can reuse it
(eggs, juvenile scale, senior tint, dead flip+grey, etc.).
"""
from __future__ import annotations
from typing import Dict, Tuple, Any
import pygame
__all__ = ["SpriteCache", "LabelCache"]
def _clamp01(x: float) -> float:
    return 0.0 if x < 0.0 else 1.0 if x > 1.0 else x
class SpriteCache:
    """Cache scaled/variant sprite surfaces + share final blits to other systems."""
    _shared = None  # singleton holder
    def __init__(self, cache_limit: int = 256) -> None:
        self.cache_limit = int(cache_limit)
        # key: (id(img), w, h, dead, hflip, variant_key) -> Surface
        self._cache: Dict[Tuple[int, int, int, bool, bool, Tuple[Any, ...]], pygame.Surface] = {}
        # NEW: what the renderer actually blitted last for each entity
        self._final_by_entity: Dict[int, pygame.Surface] = {}
    @classmethod
    def shared(cls) -> "SpriteCache":
        """Access a shared SpriteCache instance for cross-system sharing."""
        if cls._shared is None:
            cls._shared = cls()
        return cls._shared
    # ---- "final surface" sharing API -----------------------------------------
    def put_final(self, entity_id: int, surf: pygame.Surface) -> None:
        self._final_by_entity[entity_id] = surf
    def get_final(self, entity_id: int):
        return self._final_by_entity.get(entity_id)
    # ---- maintenance ---------------------------------------------------------
    def clear(self) -> None:
        self._cache.clear()
        # also clear finals when scale/atlas changes so thumbs refresh
        self._final_by_entity.clear()
    # --- transforms -----------------------------------------------------------
    def _to_grayscale_and_vflip(self, surf: pygame.Surface) -> pygame.Surface:
        """Dead look: grayscale + vertical flip (once)."""
        gs = surf.copy().convert_alpha()
        width, height = gs.get_size()
        for x in range(width):
            for y in range(height):
                r, g, b, a = gs.get_at((x, y))
                if a:
                    lum = (r * 299 + g * 587 + b * 114) // 1000  # ITU-R 601-2
                    gs.set_at((x, y), (lum, lum, lum, a))
        return pygame.transform.flip(gs, False, True)
    def _apply_senior_style(
        self,
        base: pygame.Surface,
        *,
        desaturate: float,
        tint_rgb: Tuple[int, int, int],
        outline: bool,
        outline_px: int,
        outline_color: Tuple[int, int, int, int],
    ) -> pygame.Surface:
        """
        Senior look: partial desat toward grayscale, then warm tint.
        Optionally add a small outline (1 px) using a mask.
        """
        desaturate = _clamp01(float(desaturate))
        # 1) partial desaturation (per-pixel mix toward luminance)
        img = base.copy().convert_alpha()
        w, h = img.get_size()
        if desaturate > 0.0:
            for x in range(w):
                for y in range(h):
                    r, g, b, a = img.get_at((x, y))
                    if a:
                        lum = (r * 299 + g * 587 + b * 114) // 1000
                        r = int(r + (lum - r) * desaturate)
                        g = int(g + (lum - g) * desaturate)
                        b = int(b + (lum - b) * desaturate)
                        img.set_at((x, y), (r, g, b, a))
        # 2) warm tint (fast per-pixel multiply)
        tr, tg, tb = [max(0, min(255, int(v))) for v in tint_rgb]
        if (tr, tg, tb) != (255, 255, 255):
            for x in range(w):
                for y in range(h):
                    r, g, b, a = img.get_at((x, y))
                    if a:
                        r = (r * tr) // 255
                        g = (g * tg) // 255
                        b = (b * tb) // 255
                        img.set_at((x, y), (r, g, b, a))
        if not outline or outline_px <= 0:
            return img
        # 3) tiny outline via mask (cached once per key)
        outline_px = max(1, int(outline_px))
        oc = outline_color if len(outline_color) == 4 else (outline_color[0], outline_color[1], outline_color[2], 255)
        # Build a mask off the *desat+tinted* image alpha
        mask = pygame.mask.from_surface(img)
        edge = mask.to_surface(setcolor=oc, unsetcolor=(0, 0, 0, 0))
        final = pygame.Surface((w, h), pygame.SRCALPHA)
        # Four-neighbor "dilate" look
        final.blit(edge, (-outline_px, 0))
        final.blit(edge, ( outline_px, 0))
        final.blit(edge, (0, -outline_px))
        final.blit(edge, (0,  outline_px))
        # Foreground
        final.blit(img, (0, 0))
        return final
    # --- cache API ------------------------------------------------------------
    def _variant_key(self, variant: str, style: Dict[str, Any] | None) -> Tuple[Any, ...]:
        if variant != "senior":
            return ("normal",)
        style = style or {}
        des = float(style.get("desaturate", 0.6))
        tint = tuple(int(c) for c in style.get("tint", (235, 225, 215)))
        outline = bool(style.get("outline", True))
        opx = int(style.get("outline_px", 1))
        ocol = style.get("outline_color", (40, 35, 30, 255))
        if len(ocol) == 3:
            ocol = (int(ocol[0]), int(ocol[1]), int(ocol[2]), 255)
        else:
            ocol = tuple(int(c) for c in ocol)
        return ("senior", round(des, 3), tint, outline, opx, ocol)
    def get(
        self,
        img: pygame.Surface,
        w: int,
        h: int,
        *,
        dead: bool = False,
        hflip: bool = False,
        variant: str = "normal",
        senior_style: Dict[str, Any] | None = None,
    ) -> pygame.Surface:
        """
        Return a (possibly transformed) surface:
        - scaled to (w, h)
        - dead=True: grayscale + vertical flip
        - hflip=True: horizontal flip (ignored if dead=True)
        - variant="senior": partial desat + tint + optional outline
        """
        vkey = self._variant_key(variant, senior_style)
        key = (id(img), int(w), int(h), bool(dead), bool(hflip), vkey)
        cached = self._cache.get(key)
        if cached is not None:
            return cached
        # Base scale first
        scaled = pygame.transform.smoothscale(img, (int(w), int(h)))
        if dead:
            transformed = self._to_grayscale_and_vflip(scaled)
        else:
            # optional hflip relative to the base art
            base = pygame.transform.flip(scaled, True, False) if hflip else scaled
            if vkey[0] == "senior":
                # unpack style with defaults
                _, des, tint, outline, opx, ocol = vkey
                transformed = self._apply_senior_style(
                    base,
                    desaturate=des,
                    tint_rgb=tint,
                    outline=outline,
                    outline_px=opx,
                    outline_color=ocol,
                )
            else:
                transformed = base
        # Simple LRU-ish eviction
        if len(self._cache) >= self.cache_limit and self._cache:
            self._cache.pop(next(iter(self._cache)))
        self._cache[key] = transformed
        return transformed
class LabelCache:
    """Cache rendered text surfaces for a given pygame Font."""
    def __init__(self, font) -> None:
        self.font = font
        self._cache: Dict[Tuple[str, Tuple[int, int, int]], pygame.Surface] = {}
    def clear(self) -> None:
        self._cache.clear()
    def get(self, text: str, color=(255, 255, 255)) -> pygame.Surface:
        key = (text, tuple(color))
        cached = self._cache.get(key)
        if cached is not None:
            return cached
        surf = self.font.render(text, True, color)
        self._cache[key] = surf
        return surf
```
# === FILE END: ecs\systems\renderers\cache.py ===
# === FILE START: ecs\systems\renderers\draw_sprite.py ===
```python
import pygame
from typing import Optional
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.position_component import Position
from ecs.components.core.velocity_component import Velocity
from ecs.components.fish.brain_component import Brain
from ecs.components.fish.target_intent_component import TargetIntent
from .cache import SpriteCache
def choose_facing(
    spr: Sprite,
    vel: Optional[Velocity],
    target: Optional[TargetIntent],
    pos: Position,
    last_facing: bool
):
    """
    Decide which way the fish *wants* to face (logic-facing) with hysteresis.
    We only flip when there's a clear left/right signal to avoid flicker
    while following vertical lines or sitting nearly still.
    Returns: (face_right, need_hflip_relative_to_art)
    """
    # Tunables (logical units)
    VEL_DEADZONE = 5.0                         # px/s of horizontal speed required to flip by velocity
    # Use the fish's own size to scale the target deadzone, with a floor
    target_deadzone = max(4.0, spr.base_w * 0.10)
    face_right = last_facing  # default: keep the previous facing
    # 1) Strong hint: horizontal velocity
    if vel is not None and abs(vel.dx) > VEL_DEADZONE:
        face_right = (vel.dx >= 0)
    # 2) Secondary hint: target X vs fish *center* X (with deadzone)
    elif target is not None:
        center_x = pos.x + spr.base_w * 0.5
        dx = (target.tx - center_x)
        if abs(dx) > target_deadzone:
            face_right = (dx >= 0)
        # else: keep last_facing
    # If none of the above, we keep last_facing.
    # Determine if we must flip relative to the base art
    need_hflip = (face_right != spr.faces_right)
    return face_right, need_hflip
def draw_sprite(
    screen,
    assets,
    sprite_cache: SpriteCache,
    pos: Position,
    spr: Sprite,
    brain: Optional[Brain],
    face_right: bool,
    need_hflip: bool,
    tank_pos: Optional[Position],
    scale: float,
    *,
    debug_border: bool = False,
    border_w: int = 1
):
    """
    Draw the sprite with correct orientation and dead presentation.
    - Alive: normal color; optional horizontal flip if logic-facing differs
             from the base art.
    - Dead:  grayscale + vertical flip ONLY (no horizontal flip at all).
    """
    img = assets.get(spr.image_id)
    if img is None:
        return None, None, None, None
    # Compute draw rect in screen space
    if tank_pos is not None:
        draw_x = tank_pos.x + pos.x * scale
        draw_y = tank_pos.y + pos.y * scale
        screen_w = int(spr.base_w * scale)
        screen_h = int(spr.base_h * scale)
    else:
        draw_x, draw_y = pos.x, pos.y
        screen_w, screen_h = spr.base_w, spr.base_h
    # Dead look = grayscale + vertical flip, but NEVER horizontal mirroring
    is_dead = bool(brain and brain.state == "Dead")
    apply_hflip = (need_hflip and not is_dead)
    scaled = sprite_cache.get(
        img, screen_w, screen_h,
        dead=is_dead,         # triggers grayscale + vertical flip in cache
        hflip=apply_hflip     # suppress horizontal flip when dead
    )
    ix = int(round(draw_x))
    iy = int(round(draw_y))
    screen.blit(scaled, (ix, iy))
    if debug_border:
        pygame.draw.rect(
            screen, (255, 0, 0),
            pygame.Rect(ix, iy, screen_w, screen_h),
            width=max(1, int(border_w))
        )
    return ix, iy, screen_w, screen_h
```
# === FILE END: ecs\systems\renderers\draw_sprite.py ===
# === FILE START: ecs\systems\renderers\geometry.py ===
```python
# ecs/systems/renderers/geometry.py
from typing import Optional, Tuple
from ecs.components.core.position_component import Position
from ecs.components.core.sprite_component import Sprite
from ecs.components.tags.food_pellet_component import FoodPellet
from ecs.components.fish.behavior_tuning import BehaviorTuning
from utils.geometry import get_mouth_logical as _core_mouth_logical
def entity_exists(world, eid: int) -> bool:
    comps = getattr(world, "_components", None)
    return isinstance(comps, dict) and (eid in comps)
def center_logical(pos: Position, spr: Sprite) -> Tuple[float, float]:
    return pos.x + spr.base_w * 0.5, pos.y + spr.base_h * 0.5
def pellet_center_radius(world, pellet_id: int):
    if not entity_exists(world, pellet_id):
        return None, None, None
    pos = world.get_component(pellet_id, Position)
    spr = world.get_component(pellet_id, Sprite)
    pellet = world.get_component(pellet_id, FoodPellet)
    if not pos or not spr:
        return None, None, None
    cx = pos.x + spr.base_w * 0.5
    cy = pos.y + spr.base_h * 0.5
    base_r = max(spr.base_w, spr.base_h) * 0.5
    scale = float(getattr(pellet, "radius_scale", 1.0)) if pellet else 1.0
    pr = base_r * scale
    return cx, cy, pr
def mouth_logical(pos: Position, spr: Sprite, face_right: bool):
    # Backwards compat wrapper for existing renderer code
    return _core_mouth_logical(pos, spr, face_right=face_right)
def mouth_radius_from_tuning(spr: Sprite, tuning: Optional[BehaviorTuning]):
    factor = 0.35
    if tuning is not None:
        try:
            factor = float(tuning.get("mouth_radius_factor", factor))
        except Exception:
            pass
    size = min(spr.base_w, spr.base_h)
    return max(4.0, size * factor * 0.5)
def vision_radius_from_tuning(tuning: Optional[BehaviorTuning], default: float = 200.0) -> float:
    if tuning is None:
        return float(default)
    try:
        return float(tuning.get("food_detect_radius", default))
    except Exception:
        return float(default)
```
# === FILE END: ecs\systems\renderers\geometry.py ===
# === FILE START: ecs\systems\renderers\overlay_food.py ===
```python
# ecs/systems/renderers/overlay_food.py
import pygame
from ecs.components.core.position_component import Position
from ecs.components.core.sprite_component import Sprite
from ecs.components.tags.food_pellet_component import FoodPellet
from .geometry import (
    mouth_radius_from_tuning, vision_radius_from_tuning
)
from utils.geometry import get_mouth_logical
def _pellet_center_and_radius_render(world, pellet_id, *,
                                     radius_scale: float = 1.0,
                                     off_x: float = 0.0, off_y: float = 0.0):
    """Same math the FSM uses, but local to the renderer to avoid imports."""
    comps = getattr(world, "_components", {})
    if pellet_id not in comps:
        return None, None, None
    p = world.get_component(pellet_id, Position)
    s = world.get_component(pellet_id, Sprite)
    if not p or not s:
        return None, None, None
    cx = p.x + s.base_w * 0.5 + float(off_x)
    cy = p.y + s.base_h * 0.5 + float(off_y)
    base_r = max(s.base_w, s.base_h) * 0.5
    pr = base_r * float(radius_scale)
    return cx, cy, pr
# ecs/systems/renderers/overlay_food.py  (replace the whole draw_food_debug function)
def draw_food_debug(screen, world, context,
                    pos, spr, brain, tuning,
                    face_right: bool,
                    tank_pos, scale,
                    draw_x: int, draw_y: int, screen_w: int, screen_h: int):
    # Only run if the overlay is on AND this entity is a fish (has a Brain)
    if not (context.show_fish_vision or context.show_pellet_radius or context.show_food_links):
        return
    if brain is None or tank_pos is None:
        return
    # ---------- fish center / vision ----------
    fcx = draw_x + screen_w // 2
    fcy = draw_y + screen_h // 2
    if context.show_fish_vision:
        vision = vision_radius_from_tuning(tuning, 200.0)
        pygame.draw.circle(screen, (0, 200, 255), (fcx, fcy), max(1, int(vision * scale)), 1)
    # ---------- mouth marker ----------
    mx, my = get_mouth_logical(pos, spr, face_right=face_right)  # logical
    mcx = int(round(tank_pos.x + mx * scale))
    mcy = int(round(tank_pos.y + my * scale))
    mouth_r_logical = mouth_radius_from_tuning(spr, tuning)
    pygame.draw.circle(screen, (255, 0, 255), (mcx, mcy), max(1, int(mouth_r_logical * scale)), 2)
    # ---------- targeted pellet: draw the *actual* collision circle (pr) ----------
    pe = getattr(brain, "_target_pellet", None)
    if pe is None:
        return
    ppos = world.get_component(pe, Position)
    pspr = world.get_component(pe, Sprite)
    pcmp = world.get_component(pe, FoodPellet)
    if not (ppos and pspr):
        return
    # Match the sprite blit rounding exactly
    draw_px = int(round(tank_pos.x + ppos.x * scale))
    draw_py = int(round(tank_pos.y + ppos.y * scale))
    pw = int(round(pspr.base_w * scale))
    ph = int(round(pspr.base_h * scale))
    scx = draw_px + pw // 2
    scy = draw_py + ph // 2
    # pr (logical) is exactly what the FSM uses: base half-size * radius_scale
    base_r_logical = max(pspr.base_w, pspr.base_h) * 0.5
    radius_scale = float(getattr(pcmp, "radius_scale", 1.0)) if pcmp else 1.0
    pr_screen = int(base_r_logical * radius_scale * scale)
    if context.show_pellet_radius:
        # Collision circle around pellet (this is the one compared to the mouth)
        pygame.draw.circle(screen, (80, 200, 255), (scx, scy), max(1, pr_screen), 2)
        # Optional: also show the actual eat threshold (pr + mouth_r + margin)
        eat_margin = float(tuning.get("eat_extra_margin", 6.0))
        eat_screen = int((base_r_logical * radius_scale + mouth_r_logical + eat_margin) * scale)
        pygame.draw.circle(screen, (120, 230, 255), (scx, scy), max(1, eat_screen), 1)
    if context.show_food_links:
        pygame.draw.line(
            screen, (255, 200, 0),
            (mcx, mcy), (scx, scy),
            max(1, int(context.ui.get("ui_target_line_width", 1)))
        )
def draw_target_line_from_mouth(screen, context,
                                pos, spr, brain,
                                face_right, tank_pos, scale,
                                draw_x: int, draw_y: int, screen_w: int, screen_h: int):
    if not (context.show_target_lines and brain and tank_pos is not None):
        return
    mx, my = get_mouth_logical(pos, spr, face_right=face_right)  # logical
    sx0 = int(round(tank_pos.x + mx * scale))
    sy0 = int(round(tank_pos.y + my * scale))
    sx1 = int(round(tank_pos.x + brain.tx * scale))
    sy1 = int(round(tank_pos.y + brain.ty * scale))
    pygame.draw.line(
        screen, (255, 200, 0), (sx0, sy0), (sx1, sy1),
        max(1, int(context.ui.get("ui_target_line_width", 1)))
    )
```
# === FILE END: ecs\systems\renderers\overlay_food.py ===
# === FILE START: ecs\systems\renderers\overlay_labels.py ===
```python
# ecs/systems/renderers/overlay_labels.py
import pygame
from ecs.components.fish.hunger_component import Hunger
from ecs.components.fish.health_component import Health
from ecs.components.fish.brain_component import Brain
from .cache import LabelCache
from ecs.components.fish.age_component import Age
def _state_color(state: str):
    return {
        "Cruise": (120, 200, 255),
        "Idle": (255, 220, 120),
        "Dead": (255, 120, 120),
        "LookForFood": (180, 255, 255),
        "ChaseFood": (255, 255, 180),
    }.get(state, (255, 255, 255))
def draw_state_and_bars(screen, label_cache: LabelCache,
                        draw_x: float, draw_y: float, screen_w: int, screen_h: int,
                        brain: Brain, hunger: Hunger, health: Health, age: Age,
                        *, show_labels: bool, bar_h: int, bar_gap: int, label_offset: int):
    if show_labels and brain:
        stage_suffix = ""
        if age:
            stage_suffix = f" [{age.stage}]"
        text = f"{brain.state}{stage_suffix}"
        surf = label_cache.get(text, _state_color(brain.state))
        screen.blit(surf, (draw_x, draw_y + screen_h + label_offset))
    if show_labels and hunger and health:
        hunger_ratio = hunger.hunger / max(1e-6, hunger.hunger_max)
        health_ratio = health.value / max(1e-6, health.max_value)
        bar_w = screen_w
        # Hunger bar
        bar_x = draw_x
        bar_y = draw_y - (bar_gap + bar_h)
        pygame.draw.rect(screen, (60, 60, 60), (bar_x, bar_y, bar_w, bar_h))
        pygame.draw.rect(screen, (255, 210, 80), (bar_x, bar_y, int(bar_w * hunger_ratio), bar_h))
        # Health bar
        bar_y -= bar_gap
        pygame.draw.rect(screen, (60, 60, 60), (bar_x, bar_y, bar_w, bar_h))
        pygame.draw.rect(screen, (100, 255, 120), (bar_x, bar_y, int(bar_w * health_ratio), bar_h))
    # Age bar (progress through lifespan) — shown with labels on
    if show_labels and age:
        age_ratio = max(0.0, min(1.0, age.age / max(1e-6, age.lifespan)))
        bar_w = screen_w
        bar_x = draw_x
        bar_y = draw_y - (bar_gap + bar_h) * 3  # stack below the others
        # background
        pygame.draw.rect(screen, (60, 60, 60), (bar_x, bar_y, bar_w, bar_h))
        # fill (cool→warm as it ages)
        # simple 2-color lerp from light blue to orange
        r = int(120 + (255 - 120) * age_ratio)
        g = int(200 + (140 - 200) * age_ratio)
        b = int(255 + ( 60 - 255) * age_ratio)
        pygame.draw.rect(screen, (r, g, b), (bar_x, bar_y, int(bar_w * age_ratio), bar_h))
```
# === FILE END: ecs\systems\renderers\overlay_labels.py ===
# === FILE START: ecs\systems\renderers\overlay_motion.py ===
```python
import pygame
from ecs.components.core.velocity_component import Velocity
from ecs.components.fish.steering_intent_component import SteeringIntent
def draw_velocity_arrow(screen, context, draw_x, draw_y, screen_w, screen_h, vel: Velocity):
    if not (vel and context.show_velocity_arrows): return
    end_x = draw_x + screen_w / 2 + vel.dx * float(context.ui.get("ui_velocity_arrow_scale", 0.5))
    end_y = draw_y + screen_h / 2 + vel.dy * float(context.ui.get("ui_velocity_arrow_scale", 0.5))
    pygame.draw.line(screen, (255, 255, 0),
        (draw_x + screen_w / 2, draw_y + screen_h / 2),
        (end_x, end_y), 1)
def draw_avoidance_arrow(screen, context, draw_x, draw_y, screen_w, screen_h, intent: SteeringIntent):
    if not (intent and context.show_avoidance_arrows): return
    ax = intent.dx * float(context.ui.get("ui_avoidance_arrow_scale", 40.0))
    ay = intent.dy * float(context.ui.get("ui_avoidance_arrow_scale", 40.0))
    pygame.draw.line(screen, (255, 100, 0),
        (draw_x + screen_w / 2, draw_y + screen_h / 2),
        (draw_x + screen_w / 2 + ax, draw_y + screen_h / 2 + ay), 1)
```
# === FILE END: ecs\systems\renderers\overlay_motion.py ===
# === FILE START: ecs\systems\rendering\__init__.py ===
```python
```
# === FILE END: ecs\systems\rendering\__init__.py ===
# === FILE START: ecs\systems\rendering\fish_overlay_system.py ===
```python
# ecs/systems/fish_overlay_system.py
import pygame
from typing import Optional
from ecs.components.core.position_component import Position
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.core.velocity_component import Velocity
from ecs.components.fish.brain_component import Brain
from ecs.components.fish.hunger_component import Hunger
from ecs.components.fish.health_component import Health
from ecs.components.fish.behavior_tuning import BehaviorTuning
from ecs.components.fish.target_intent_component import TargetIntent
from ecs.components.fish.steering_intent_component import SteeringIntent
from ecs.components.fish.age_component import Age
from ecs.systems.renderers import (
    LabelCache,
    choose_facing,
    draw_state_and_bars,
    draw_food_debug,
    draw_target_line_from_mouth,
    draw_velocity_arrow,
    draw_avoidance_arrow,
)
class FishOverlaySystem:
    def __init__(self, screen, assets, context, font_size: int = 14):
        self.screen = screen
        self.assets = assets
        self.context = context
        # Font safety for headless/tests
        if not pygame.get_init():
            pygame.init()  # why: avoid crashes in ad-hoc/manual runs
        if not pygame.font.get_init():
            pygame.font.init()
        self.font = pygame.font.SysFont("arial", font_size)
        # Caches/state
        self.label_cache = LabelCache(self.font)  # cached text surfaces
        self._last_facing: dict[int, bool] = {}   # eid -> faces_right
        # UI sizing (stable defaults; tweak via context if present)
        self._bar_h = int(getattr(self.context, "overlay_bar_h", 8))
        self._bar_gap = int(getattr(self.context, "overlay_bar_gap", 4))
        # y-offset (in px) for state label relative to sprite top
        self._label_offset = int(getattr(self.context, "overlay_label_offset", -4))
    def update(self, world, dt):
        scale = float(getattr(self.context, "tank_scale", 1.0))
        for e in world.entities_with(Position, Sprite):
            pos: Position = world.get_component(e, Position)
            spr: Sprite = world.get_component(e, Sprite)
            vel: Optional[Velocity] = world.get_component(e, Velocity)
            brain: Optional[Brain] = world.get_component(e, Brain)
            hunger: Optional[Hunger] = world.get_component(e, Hunger)
            health: Optional[Health] = world.get_component(e, Health)
            tuning: Optional[BehaviorTuning] = world.get_component(e, BehaviorTuning)
            target: Optional[TargetIntent] = world.get_component(e, TargetIntent)
            steering: Optional[SteeringIntent] = world.get_component(e, SteeringIntent)
            tank_ref: Optional[TankRef] = world.get_component(e, TankRef)
            tank_pos: Optional[Position] = world.get_component(tank_ref.tank_entity, Position) if tank_ref else None
            age: Optional[Age] = world.get_component(e, Age)
            # Only fish linked to a tank get overlays
            if tank_pos is None:
                continue
            # Facing state (persistent for stable mouth anchoring)
            last_face = self._last_facing.get(e, bool(getattr(spr, "faces_right", True)))
            face_right, _ = choose_facing(spr, vel, target, pos, last_face)
            self._last_facing[e] = face_right
            # On-screen rect
            draw_x = int(round(tank_pos.x + pos.x * scale))
            draw_y = int(round(tank_pos.y + pos.y * scale))
            screen_w = int(round(spr.base_w * scale))
            screen_h = int(round(spr.base_h * scale))
            # 1) State label + hunger/health bars
            draw_state_and_bars(
                self.screen,
                self.label_cache,
                draw_x,
                draw_y,
                screen_w,
                screen_h,
                brain,
                hunger,
                health,
                age,
                show_labels=bool(getattr(self.context, "show_behavior_labels", True)),
                bar_h=self._bar_h,
                bar_gap=self._bar_gap,
                label_offset=self._label_offset,
            )
            # 2) Food overlays (vision ring, pellet radius, mouth circle + link)
            draw_food_debug(
                self.screen,
                world,
                self.context,
                pos,
                spr,
                brain,
                tuning,
                face_right,
                tank_pos,
                scale,
                draw_x,
                draw_y,
                screen_w,
                screen_h,
            )
            # 3) Target line from mouth
            draw_target_line_from_mouth(
                self.screen,
                self.context,
                pos,
                spr,
                brain,
                face_right,
                tank_pos,
                scale,
                draw_x,
                draw_y,
                screen_w,
                screen_h,
            )
            # 4) Motion vectors
            draw_velocity_arrow(self.screen, self.context, draw_x, draw_y, screen_w, screen_h, vel)
            draw_avoidance_arrow(self.screen, self.context, draw_x, draw_y, screen_w, screen_h, steering)
```
# === FILE END: ecs\systems\rendering\fish_overlay_system.py ===
# === FILE START: ecs\systems\rendering\sprite_render_system.py ===
```python
# ecs/systems/rendering/sprite_render_system.py
from __future__ import annotations
import pygame
from typing import Optional
from ecs.components.core.position_component import Position
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.core.velocity_component import Velocity
from ecs.components.fish.brain_component import Brain
from ecs.components.fish.target_intent_component import TargetIntent
from ecs.components.fish.age_component import Age
from ecs.systems.renderers import choose_facing
from ecs.systems.renderers.cache import SpriteCache
class SpriteRenderSystem:
    """
    Draw fish sprites and publish per-fish screen rects for click hit-testing.
    WHY: MouseSystem._hit_test_fish reads context.fish_screen_rects.
    If this list is missing or stale, clicks won't open panels.
    """
    def __init__(self, screen, assets, context, cache_limit: int = 256):
        self.screen = screen
        self.assets = assets
        self.context = context
        self.sprite_cache = SpriteCache.shared()
        ui = getattr(context, "ui", {}) or {}
        self.sprite_cache.cache_limit = int(ui.get("render_cache_limit", cache_limit))
        self._last_scale: Optional[float] = None
        self._last_facing: dict[int, bool] = {}
    def _senior_style_cfg(self) -> dict:
        aging = getattr(self.context, "aging", {}) or {}
        return {
            "desaturate": float(aging.get("senior_desaturate", 0.6)),
            "tint": tuple(aging.get("senior_tint", [235, 225, 215])),
            "outline": bool(aging.get("senior_outline", True)),
            "outline_px": int(aging.get("senior_outline_px", 1)),
            "outline_color": tuple(aging.get("senior_outline_color", [40, 35, 30, 255])),
        }
    def update(self, world, dt) -> None:
        # Invalidate cache when tank scale changes
        scale = float(getattr(self.context, "tank_scale", 1.0))
        if self._last_scale != scale:
            self.sprite_cache.clear()
            self._last_scale = scale
        # Rebuild hit rects every frame
        self.context.fish_screen_rects = []  # list[(entity_id, pygame.Rect)]
        for e in world.entities_with(Position, Sprite):
            pos: Position = world.get_component(e, Position)
            spr: Sprite = world.get_component(e, Sprite)
            vel: Optional[Velocity] = world.get_component(e, Velocity)
            brain: Optional[Brain] = world.get_component(e, Brain)
            age: Optional[Age] = world.get_component(e, Age)
            tank_ref: Optional[TankRef] = world.get_component(e, TankRef)
            target: Optional[TargetIntent] = world.get_component(e, TargetIntent)
            if not tank_ref:
                continue
            tank_pos: Optional[Position] = world.get_component(tank_ref.tank_entity, Position)
            if not tank_pos:
                continue
            # Facing/hflip
            last_face = self._last_facing.get(e, spr.faces_right)
            face_right, need_hflip = choose_facing(spr, vel, target, pos, last_face)
            self._last_facing[e] = face_right
            # World → screen
            base_w = int(round(spr.base_w * scale))
            base_h = int(round(spr.base_h * scale))
            draw_x = int(round(tank_pos.x + pos.x * scale))
            draw_y = int(round(tank_pos.y + pos.y * scale))
            # Stage/variant
            stage = getattr(age, "stage", "Adult") if age else "Adult"
            is_dead = (getattr(brain, "state", "") == "Dead")
            is_senior = bool(age and stage == "Senior")
            is_juvenile = bool(age and stage == "Juvenile")
            is_egg = bool(age and stage == "Egg")
            # Base asset
            base_img = self.assets.get(getattr(spr, "image_id", None))
            if is_egg:
                base_img = self.assets.get("egg") or base_img
            if base_img is None:
                continue
            # Size selection (cards are elsewhere; here we render full-size fish w/ juvenile scaling)
            screen_w = base_w
            screen_h = base_h
            if is_juvenile:
                juvenile_scale = float((getattr(self.context, "aging", {}) or {}).get("juvenile_scale", 0.5))
                screen_w = max(1, int(round(base_w * juvenile_scale)))
                screen_h = max(1, int(round(base_h * juvenile_scale)))
            # Variant flags
            variant = "normal"
            senior_style = None
            if (not is_dead) and is_senior:
                variant = "senior"
                senior_style = self._senior_style_cfg()
            # Finals
            surf = self.sprite_cache.get(
                base_img,
                screen_w, screen_h,
                dead=is_dead,
                hflip=(need_hflip and not is_dead),
                variant=variant,
                senior_style=senior_style,
            )
            # Center scaled fish inside its base box so geometry is stable
            ix = int(round(draw_x + (base_w - screen_w) * 0.5))
            iy = int(round(draw_y + (base_h - screen_h) * 0.5))
            self.screen.blit(surf, (ix, iy))
            # Publish clickable rect = drawn rect
            self.context.fish_screen_rects.append((e, pygame.Rect(ix, iy, screen_w, screen_h)))
```
# === FILE END: ecs\systems\rendering\sprite_render_system.py ===
# === FILE START: ecs\systems\rendering\tank_render_system.py ===
```python
# ecs/systems/tank_render_system.py
import pygame
from ecs.components.core.position_component import Position
from ecs.components.core.bounds_component import Bounds
from ecs.components.core.tank_style_component import TankStyle
from ecs.components.core.tank_label_component import TankLabel
class TankRenderSystem:
    def __init__(self, screen, assets=None, context=None):
        self.screen = screen
        self.assets = assets
        self.context = context
        # lazy init (font may depend on size from ui config)
        self._font_cache = {}
    def _get_font(self, size: int):
        if size not in self._font_cache:
            self._font_cache[size] = pygame.font.SysFont("arial", int(size))
        return self._font_cache[size]
    def update(self, world, dt):
        for e in world.entities_with(Position, Bounds, TankStyle):
            pos = world.get_component(e, Position)
            bounds = world.get_component(e, Bounds)
            style = world.get_component(e, TankStyle)
            x, y = pos.x, pos.y
            w, h = bounds.width, bounds.height
            # ---------- background ----------
            if self.assets is not None and "tank_bg" in self.assets.images:
                bg = self.assets.get("tank_bg")
                scaled = pygame.transform.smoothscale(bg, (w, h))
                self.screen.blit(scaled, (x, y))
            else:
                pygame.draw.rect(self.screen, (10, 20, 40), pygame.Rect(x, y, w, h))
            # ---------- bottom-center label (if present) ----------
            label = world.get_component(e, TankLabel)
            if label and (label.text or label.text == ""):
                ui = (self.context.ui if self.context else {}) or {}
                size   = int(ui.get("ui_tank_label_size",  max(1, label.size)))
                color  = tuple(ui.get("ui_tank_label_color", list(label.color)))
                margin = int(ui.get("ui_tank_label_bottom_margin", 22))
                shadow = bool(ui.get("ui_tank_label_shadow", True))
                font = self._get_font(size)
                surf = font.render(label.text, True, color)
                tx = x + (w - surf.get_width()) // 2
                ty = y + h - margin - surf.get_height()
                # simple shadow for readability on the substrate
                if shadow:
                    shadow_surf = font.render(label.text, True, (0, 0, 0))
                    self.screen.blit(shadow_surf, (tx + 2, ty + 2))
                self.screen.blit(surf, (tx, ty))
            # ---------- border ----------
            pygame.draw.rect(
                self.screen,
                style.border_color,
                pygame.Rect(x, y, w, h),
                style.thickness
            )
```
# === FILE END: ecs\systems\rendering\tank_render_system.py ===
# === FILE START: ecs\systems\ui\__init__.py ===
```python
```
# === FILE END: ecs\systems\ui\__init__.py ===
# === FILE START: ecs\systems\ui\cursor_system.py ===
```python
# ecs/systems/cursor_system.py
import pygame
class CursorSystem:
    """
    Switches the mouse cursor based on selected tool:
      - feeding_enabled -> pellet.png
      - egging_enabled  -> egg.png
      - else            -> default arrow
    """
    def __init__(self, screen, assets, context):
        self.screen = screen
        self.assets = assets
        self.context = context
        self._last_state = None
        self._last_cursor_ok = None
    def _set_image_cursor(self, key, hotspot="center", max_dim=48):
        surf = self.assets.get(key)
        if surf is None:
            if self._last_cursor_ok is not False:
                print(f"⚠ cursor asset '{key}' not found; using default cursor")
                self._last_cursor_ok = False
            pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)
            return
        w, h = surf.get_width(), surf.get_height()
        if max(w, h) > max_dim:
            s = max_dim / max(w, h)
            surf = pygame.transform.smoothscale(surf, (int(w * s), int(h * s)))
            w, h = surf.get_width(), surf.get_height()
        hs = (w // 2, h // 2) if hotspot == "center" else (0, 0)
        try:
            cursor = pygame.cursors.Cursor(hs, surf)
            pygame.mouse.set_cursor(cursor)
            pygame.mouse.set_visible(True)
            self._last_cursor_ok = True
        except Exception as exc:
            if self._last_cursor_ok is not False:
                print(f"⚠ Could not set custom cursor ({exc}); defaulting")
            pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)
            self._last_cursor_ok = False
    def _apply_cursor(self):
        if getattr(self.context, "feeding_enabled", False):
            self._set_image_cursor("pellet")
        elif getattr(self.context, "egging_enabled", False):
            self._set_image_cursor("egg")
        else:
            pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_ARROW)
            pygame.mouse.set_visible(True)
    def update(self, world, dt):
        state = (
            bool(getattr(self.context, "feeding_enabled", False)),
            bool(getattr(self.context, "egging_enabled", False)),
        )
        if state == self._last_state:
            return
        self._last_state = state
        self._apply_cursor()
```
# === FILE END: ecs\systems\ui\cursor_system.py ===
# === FILE START: ecs\systems\ui\fish_inspector_system.py ===
```python
# ecs/systems/ui/fish_inspector_system.py
from __future__ import annotations
import pygame
from typing import Optional
from ecs.systems.ui.widgets.thumb_provider import ThumbProvider
from ecs.components.fish.species_component import Species
from ecs.components.core.sprite_component import Sprite
from ecs.components.fish.age_component import Age
from ecs.components.fish.brain_component import Brain
from ecs.components.fish.health_component import Health
from ecs.components.fish.hunger_component import Hunger
class FishInspectorSystem:
    """
    Simple, non-modal inspector for a single fish:
    - Opens when MouseSystem sets: context.show_fish_inspector = True and context.fish_inspector_entity = <eid>
    - Small top-left panel; uses ThumbProvider.card_thumb(...) for the portrait.
    - RMB close is handled in MouseSystem (global cancel); we simply hide if flag is False.
    """
    THUMB_BOX = 72
    W = 260
    H = 160
    PAD = 12
    def __init__(self, screen: pygame.Surface, assets, context):
        self.screen = screen
        self.assets = assets
        self.ctx = context
        self.thumbs = ThumbProvider(assets, context)
    def update(self, world, dt: float) -> None:
        if not getattr(self.ctx, "show_fish_inspector", False):
            return
        eid = getattr(self.ctx, "fish_inspector_entity", None)
        if not isinstance(eid, int):
            return
        # Anchor (top-left), or at a point provided by the mouse
        at = getattr(self.ctx, "fish_inspector_at", None)
        x = 12 if not at else max(8, int(at[0]) - self.W // 2)
        y = 12 if not at else max(8, int(at[1]) - self.H // 2)
        r = pygame.Rect(x, y, self.W, self.H)
        self._draw_panel_bg(r)
        self._draw_body(world, eid, r)
    # ---- internals ----
    def _draw_panel_bg(self, r: pygame.Rect) -> None:
        surf = self.screen
        # rounded bg + stroke
        pygame.draw.rect(surf, (22, 26, 32), r, border_radius=12)
        pygame.draw.rect(surf, (62, 70, 84), r, width=2, border_radius=12)
        # title
        font = pygame.font.SysFont(None, 18)
        title = font.render("Inspector", True, (235, 240, 245))
        surf.blit(title, (r.x + self.PAD, r.y + self.PAD))
        # close hint (visual only; RMB is actual close)
        hint = font.render("RMB to close", True, (150, 160, 170))
        surf.blit(hint, (r.right - hint.get_width() - self.PAD, r.y + self.PAD))
    def _draw_body(self, world, eid: int, r: pygame.Rect) -> None:
        surf = self.screen
        body = pygame.Rect(r.x + self.PAD, r.y + self.PAD + 22, r.w - 2 * self.PAD, r.h - (self.PAD + 22 + self.PAD))
        # Portrait uses the SAME pipeline as Fish Window (and tank cards)
        thumb = self.thumbs.card_thumb(world, eid, self.THUMB_BOX)
        tw, th = thumb.get_size()
        tx = body.x
        ty = body.y + max(0, (self.THUMB_BOX - th) // 2)
        surf.blit(thumb, (tx, ty))
        # Info column
        info_x = body.x + self.THUMB_BOX + 10
        info_w = max(0, body.w - self.THUMB_BOX - 10)
        info = pygame.Rect(info_x, body.y, info_w, body.h)
        font = pygame.font.SysFont(None, 14)
        sp: Optional[Species] = world.get_component(eid, Species)
        age: Optional[Age] = world.get_component(eid, Age)
        br: Optional[Brain] = world.get_component(eid, Brain)
        hp: Optional[Health] = world.get_component(eid, Health)
        hg: Optional[Hunger] = world.get_component(eid, Hunger)
        def _pct(v, mx) -> str:
            try:
                return f"{int(round(100.0 * float(v) / max(1.0, float(mx))))}%"
            except Exception:
                return "-"
        lines = [
            f"Species: {getattr(sp, 'display_name', 'Unknown')}",
            f"Stage:   {getattr(age, 'stage', 'Unknown')}",
            f"Age:     {int(getattr(age, 'age', 0.0))}/{int(getattr(age, 'lifespan', 0.0))}",
            f"Health:  {int(getattr(hp, 'value', 0.0))}/{int(getattr(hp, 'max_value', 0.0))}",
            f"Hunger:  {int(getattr(hg, 'hunger', 0.0))}/{int(getattr(hg, 'hunger_max', 100.0))} ({_pct(getattr(hg,'hunger',0.0), getattr(hg,'hunger_max',100.0))})",
            f"Brain:   {getattr(br, 'state', 'Unknown')}",
        ]
        y = info.y
        for s in lines:
            surf.blit(font.render(s, True, (230, 235, 245)), (info.x, y))
            y += 18
```
# === FILE END: ecs\systems\ui\fish_inspector_system.py ===
# === FILE START: ecs\systems\ui\fish_window_system.py ===
```python
# ecs/systems/ui/fish_window_system.py
from __future__ import annotations
import pygame
from typing import Optional, List
from ecs.components.core.sprite_component import Sprite
from ecs.components.fish.species_component import Species
from ecs.components.fish.hunger_component import Hunger
from ecs.components.fish.health_component import Health
from ecs.components.fish.age_component import Age
from ecs.components.fish.brain_component import Brain
from ecs.systems.ui.widgets.modal_window import ModalWindow
from ecs.systems.ui.widgets.scrollbox import ScrollBox
from ecs.systems.ui.widgets.grid_layout import CardGrid
from ecs.systems.ui.widgets.thumb_provider import ThumbProvider
class FishWindowSystem:
    # Button
    BTN_PAD_X = 14
    BTN_PAD_Y = 8
    WIN_MARGIN = 20
    CLR_BTN_BG = (30, 30, 30)
    CLR_BTN_BG_HOVER = (45, 45, 45)
    CLR_BTN_BORDER = (160, 175, 200)
    CLR_BTN_TEXT = (235, 240, 255)
    # Window
    WIN_PAD = 28
    TITLE_GAP = 18
    # Cards
    GRID_GUTTER_X = 40
    GRID_GUTTER_Y = 26
    CARD_W = 300
    CARD_H = 120
    CARD_RADIUS = 12
    CARD_PAD = 14
    SPRITE_BOX = 72
    TEXT_LEFT = 16
    GAP = 10
    CLR_CARD_BG = (28, 34, 48)
    CLR_CARD_BORDER = (90, 110, 150)
    CLR_TEXT = (235, 240, 255)
    CLR_SUB = (180, 195, 215)
    # Bars
    BAR_H = 10
    BAR_GAP = 6
    CLR_BAR_BG = (60, 70, 90)
    CLR_BAR_HUNGER = (255, 220, 80)
    CLR_BAR_HEALTH = (110, 255, 120)
    # Scroll
    SCROLL_W = 10
    SCROLL_PAD = 8
    def __init__(self, screen: pygame.Surface, assets, context):
        self.screen = screen
        self.assets = assets
        self.context = context
        self._fonts: dict[int, pygame.font.Font] = {}
        self.modal = ModalWindow(screen, context)
        self.scroll = ScrollBox()
        self.grid = CardGrid(self.CARD_W, self.CARD_H, self.GRID_GUTTER_X, self.GRID_GUTTER_Y)
        self.thumbs = ThumbProvider(self.assets, self.context)
        self._list_view_rect: Optional[pygame.Rect] = None
        self._scroll_track_rect: Optional[pygame.Rect] = None
    # ---------------- fonts/sizing ----------------
    def _font(self, px: int) -> pygame.font.Font:
        f = self._fonts.get(px)
        if f is None:
            f = pygame.font.SysFont("arial", int(px))
            self._fonts[px] = f
        return f
    def _ui_sizes(self) -> dict:
        base = int((getattr(self.context, "ui", {}) or {}).get("ui_font_size", 14))
        return {"title": base + 10, "name": base + 4, "meta": base}
    # ---------------- lifecycle ----------------
    def update(self, world, dt: float) -> None:
        self._draw_button()
        if bool(getattr(self.context, "show_fish_window", False)):
            self._draw_window(world)
        else:
            if getattr(self.context, "ui_modal_active", False):
                self.context.ui_modal_active = False
                self.context.ui_modal_whitelist = None
    # ---------------- UI: top-right button ----------------
    def _draw_button(self) -> None:
        sizes = self._ui_sizes()
        label = "Fish"
        font = self._font(sizes["name"])
        sw, sh = self.screen.get_size()
        tsurf = font.render(label, True, self.CLR_BTN_TEXT)
        tw, th = tsurf.get_size()
        w = tw + self.BTN_PAD_X * 2
        h = th + self.BTN_PAD_Y * 2
        x = sw - self.WIN_MARGIN - w
        y = self.WIN_MARGIN
        rect = pygame.Rect(x, y, w, h)
        mx, my = pygame.mouse.get_pos()
        hover = rect.collidepoint(mx, my)
        pygame.draw.rect(self.screen, self.CLR_BTN_BG_HOVER if hover else self.CLR_BTN_BG, rect, border_radius=8)
        pygame.draw.rect(self.screen, self.CLR_BTN_BORDER, rect, width=1, border_radius=8)
        self.screen.blit(tsurf, (rect.x + self.BTN_PAD_X, rect.y + self.BTN_PAD_Y))
        self.context.fish_button_rect = rect
    # ---------------- window and contents ----------------
    def _draw_window(self, world) -> None:
        # Modal chrome + strict gating
        win_rect, content_view, close_rect, title_surf = self.modal.open("Fish")
        self.context.ui_modal_active = True
        self.context.ui_modal_whitelist = [win_rect, close_rect]
        self.context.fish_window_rect = win_rect
        self.context.fish_close_rect = close_rect
        self.screen.blit(title_surf, (win_rect.x + self.WIN_PAD, win_rect.y + self.WIN_PAD))
        # list viewport
        raw_view = pygame.Rect(
            content_view.x,
            content_view.y + self.TITLE_GAP,
            content_view.w - self.SCROLL_W - self.SCROLL_PAD,
            content_view.h - self.TITLE_GAP,
        )
        # guard: ensure positive drawing area
        view_w = max(self.CARD_W, raw_view.w)
        view_h = max(self.CARD_H + 1, raw_view.h)
        view = pygame.Rect(raw_view.x, raw_view.y, view_w, view_h)
        track = pygame.Rect(view.right + self.SCROLL_PAD, view.y, self.SCROLL_W, view.h)
        self._list_view_rect = view
        self._scroll_track_rect = track
        fishes = self._collect_fish(world)
        # scroll extent
        cols, rows, grid_x = self.grid.measure(view.w, len(fishes))
        content_h = rows * self.CARD_H + max(0, rows - 1) * self.GRID_GUTTER_Y
        # ScrollBox API (sync + on_wheel)
        self.scroll.sync(content_h, view.h)
        wheel = getattr(self.context, "ui_wheel_event", None)
        if wheel:
            wx, wy = wheel.get("x", 0), wheel.get("y", 0)
            if view.collidepoint(wx, wy) or track.collidepoint(wx, wy):
                dy = int(wheel.get("dy", 0))
                delta_px = -dy * getattr(self.scroll, "wheel_step_px", 60)
                self.scroll.on_wheel(delta_px)
            self.context.ui_wheel_event = None
        # clip to list viewport
        old_clip = self.screen.get_clip()
        self.screen.set_clip(view)
        yoff = -int(self.scroll.scroll_y)
        if not fishes:
            # helpful empty state
            hint = self._font(self._ui_sizes()["meta"]).render("No fish found", True, (150, 160, 180))
            hx = view.x + (view.w - hint.get_width()) // 2
            hy = view.y + (view.h - hint.get_height()) // 2
            self.screen.blit(hint, (hx, hy))
        else:
            for idx, info in enumerate(fishes):
                cx, cy = self.grid.pos(idx, cols, grid_x)
                card_rect = pygame.Rect(view.x + cx, view.y + cy + yoff, self.CARD_W, self.CARD_H)
                self._draw_card(card_rect, info)
        self.screen.set_clip(old_clip)
        # draw scrollbar
        self.scroll.draw_scrollbar(self.screen, track)
    def _collect_fish(self, world) -> list[dict]:
        """Be resilient to different ECS shapes; return list of fish info dicts."""
        infos = []
        # Helper to fetch a component for an entity, across ECS variants
        def _fetch(e, comp):
            # try world.get_component(e, Comp)
            gc = getattr(world, "get_component", None)
            if callable(gc):
                try:
                    got = gc(e, comp)
                    if got is not None:
                        return got
                except Exception:
                    pass
            # try world.components[Comp][e]
            comps = getattr(world, "components", None)
            if isinstance(comps, dict) and comp in comps:
                try:
                    return comps[comp].get(e)
                except Exception:
                    pass
            return None
        # 1) Best path: entities_with(Species, Sprite)
        ew = getattr(world, "entities_with", None)
        if callable(ew):
            try:
                for e in ew(Species, Sprite):
                    sp = _fetch(e, Species)
                    spr = _fetch(e, Sprite)
                    if not (sp and spr):
                        continue
                    infos.append(dict(
                        eid=e,
                        species=sp,
                        sprite=spr,
                        age=_fetch(e, Age),
                        brain=_fetch(e, Brain),
                        hunger=_fetch(e, Hunger),
                        health=_fetch(e, Health),
                    ))
                if infos:
                    return infos
            except Exception:
                pass
        # 2) Fallback: from components maps
        comps = getattr(world, "components", None)
        if isinstance(comps, dict):
            source_ids = None
            if Species in comps and isinstance(comps[Species], dict):
                source_ids = list(comps[Species].keys())
            elif Sprite in comps and isinstance(comps[Sprite], dict):
                source_ids = list(comps[Sprite].keys())
            if source_ids:
                for e in source_ids:
                    sp = _fetch(e, Species)
                    spr = _fetch(e, Sprite)
                    if not (sp and spr):
                        continue
                    infos.append(dict(
                        eid=e,
                        species=sp,
                        sprite=spr,
                        age=_fetch(e, Age),
                        brain=_fetch(e, Brain),
                        hunger=_fetch(e, Hunger),
                        health=_fetch(e, Health),
                    ))
                if infos:
                    return infos
        # 3) Last resort: iterate any entity list the world exposes
        for attr in ("entities", "all_entities", "entity_ids"):
            seq = getattr(world, attr, None)
            if not seq:
                continue
            try:
                for e in list(seq):
                    sp = _fetch(e, Species)
                    spr = _fetch(e, Sprite)
                    if not (sp and spr):
                        continue
                    infos.append(dict(
                        eid=e,
                        species=sp,
                        sprite=spr,
                        age=_fetch(e, Age),
                        brain=_fetch(e, Brain),
                        hunger=_fetch(e, Hunger),
                        health=_fetch(e, Health),
                    ))
            except Exception:
                pass
            if infos:
                return infos
        return infos  # possibly empty, caller will show "No fish found"
    def _draw_card(self, rect: pygame.Rect, info: dict) -> None:
        pygame.draw.rect(self.screen, self.CLR_CARD_BG, rect, border_radius=self.CARD_RADIUS)
        pygame.draw.rect(self.screen, self.CLR_CARD_BORDER, rect, width=1, border_radius=self.CARD_RADIUS)
        tbox = pygame.Rect(rect.x + self.CARD_PAD, rect.y + self.CARD_PAD, self.SPRITE_BOX, self.SPRITE_BOX)
        stage = getattr(info.get("age"), "stage", "Adult") if info.get("age") else "Adult"
        brain = getattr(info.get("brain"), "state", "Cruise") if info.get("brain") else "Cruise"
        dead = (brain == "Dead")
        if stage == "Egg":
            tw, th = 72, 72
            surf = self.thumbs.get(info["sprite"], info.get("age"), info.get("brain"), info.get("health"), self.SPRITE_BOX)
        else:
            if stage == "Juvenile":
                tw, th = 36, 24
            else:
                tw, th = 72, 48
            surf = self.thumbs.get(info["sprite"], info.get("age"), info.get("brain"), info.get("health"), self.SPRITE_BOX)
        # center in box based on returned surf size
        if surf is not None and isinstance(surf, pygame.Surface):
            tw, th = surf.get_width(), surf.get_height()
            sx = tbox.x + (tbox.w - tw) // 2
            sy = tbox.y + (tbox.h - th) // 2
            self.screen.blit(surf, (sx, sy))
        sizes = self._ui_sizes()
        name_font = self._font(sizes["name"])
        meta_font = self._font(sizes["meta"])
        species: Species = info["species"]
        name = species.display_name if getattr(species, "display_name", None) else species.species_id
        name_surf = name_font.render(name, True, self.CLR_TEXT)
        self.screen.blit(name_surf, (rect.x + self.CARD_PAD + self.SPRITE_BOX + self.TEXT_LEFT, rect.y + self.CARD_PAD))
        meta_y = rect.y + self.CARD_PAD + 28
        age: Optional[Age] = info.get("age")
        if age:
            stage_surf = meta_font.render(f"Stage: {age.stage}", True, self.CLR_SUB)
            self.screen.blit(stage_surf, (rect.x + self.CARD_PAD + self.SPRITE_BOX + self.TEXT_LEFT, meta_y))
            meta_y += self.GAP
        bar_x = rect.x + self.CARD_PAD + self.SPRITE_BOX + self.TEXT_LEFT
        bar_y = rect.y + rect.h - self.CARD_PAD - self.BAR_H * 2 - self.BAR_GAP
        self._draw_bar(bar_x, bar_y, rect.w - (bar_x - rect.x) - self.CARD_PAD, self.BAR_H,
                       info.get("hunger"), self.CLR_BAR_HUNGER, key="hunger")
        bar_y += self.BAR_H + self.BAR_GAP
        self._draw_bar(bar_x, bar_y, rect.w - (bar_x - rect.x) - self.CARD_PAD, self.BAR_H,
                       info.get("health"), self.CLR_BAR_HEALTH, key="health")
    def _draw_bar(self, x: int, y: int, w: int, h: int, comp, clr_fill, key: str) -> None:
        pygame.draw.rect(self.screen, self.CLR_BAR_BG, pygame.Rect(x, y, w, h), border_radius=4)
        if comp is None:
            return
        if key == "hunger":
            val, maxv = float(getattr(comp, "hunger", 0.0)), float(getattr(comp, "hunger_max", 1.0))
        else:
            val, maxv = float(getattr(comp, "value", 0.0)), float(getattr(comp, "max_value", 1.0))
        pct = 0.0 if maxv <= 0 else max(0.0, min(1.0, val / maxv))
        fw = int(w * pct)
        if fw > 0:
            pygame.draw.rect(self.screen, clr_fill, pygame.Rect(x, y, fw, h), border_radius=4)
```
# === FILE END: ecs\systems\ui\fish_window_system.py ===
# === FILE START: ecs\systems\ui\hotkeys_system.py ===
```python
# ecs/systems/ui/hotkeys_system.py
import pygame
class HotkeysSystem:
    """
    Handles *only* key presses that toggle state or pause the sim.
    (No text entry and no spawning here.)
    """
    def __init__(self, context):
        self.context = context
    # InputRouter will call this
    def handle_event(self, event: pygame.event.Event) -> None:
        if event.type != pygame.KEYDOWN:
            return
        k = event.key
        if k == pygame.K_SPACE:
            self.context.toggle_pause()
        elif k == pygame.K_t:
            self.context.show_target_lines = not self.context.show_target_lines
        elif k == pygame.K_f:
            any_on = (self.context.show_fish_vision
                      or self.context.show_pellet_radius
                      or self.context.show_food_links)
            turn_on = not any_on
            self.context.show_fish_vision = turn_on
            self.context.show_pellet_radius = turn_on
            self.context.show_food_links = turn_on
        elif k == pygame.K_v:
            self.context.show_velocity_arrows = not self.context.show_velocity_arrows
        elif k == pygame.K_a:
            self.context.show_avoidance_arrows = not self.context.show_avoidance_arrows
        elif k == pygame.K_b:
            self.context.show_behavior_labels = not self.context.show_behavior_labels
            self.context.show_stats_bars = self.context.show_behavior_labels
        elif k == pygame.K_F1:
            self.context.show_debug_overlay = not self.context.show_debug_overlay
        elif k == pygame.K_o:
            # Swim-area overlay (drawn even if F1 panel is off)
            self.context.show_swim_floor_debug = not bool(
                getattr(self.context, "show_swim_floor_debug", False)
            )
        elif k == pygame.K_ESCAPE:
            # Respect debug_escape_quit like before (window close is handled in game.py)
            if getattr(self.context, "debug_escape_quit", False):
                self.context.running = False
    def update(self, world, dt: float) -> None:
        return
```
# === FILE END: ecs\systems\ui\hotkeys_system.py ===
# === FILE START: ecs\systems\ui\input_router.py ===
```python
# ecs/systems/ui/input_router.py
"""
InputRouter
-----------
Tiny dispatcher that forwards pygame events to keyboard and mouse subsystems.
Critically, it forwards TEXTINPUT while label editing is active so typing works.
"""
import pygame
from typing import Optional
class InputRouter:
    def __init__(self, keyboard_system, mouse_system):
        self.keyboard = keyboard_system
        self.mouse = mouse_system
    def handle_event(self, event: pygame.event.Event) -> None:
        et = event.type
        # --- Keyboard first: it may consume events (e.g., while editing label) ---
        if et == pygame.KEYDOWN:
            self.keyboard.handle_keydown(event)
            return  # nothing else should also “press the key”
        elif et == pygame.TEXTINPUT:
            self.keyboard.handle_textinput(event)
            return
        # --- Mouse events to mouse system ---
        if et in (pygame.MOUSEBUTTONDOWN, pygame.MOUSEBUTTONUP, pygame.MOUSEMOTION, pygame.MOUSEWHEEL):
            self.mouse.handle_mouse_event(event)
            return
        # Everything else is ignored by input stack (resize handled in scene)
        return
```
# === FILE END: ecs\systems\ui\input_router.py ===
# === FILE START: ecs\systems\ui\keyboard_system.py ===
```python
# ecs/systems/ui/keyboard_system.py
from __future__ import annotations
import pygame
from typing import Optional
from ecs.systems.ui.debug import debug_controller as dbg
class KeyboardSystem:
    """
    Dispatcher-only:
      SPACE  -> pause/unpause
      L      -> begin label edit (if provided)
      F1     -> dbg.select_tab(ctx, "legend")
      F2     -> dbg.select_tab(ctx, "motion")
      F3     -> dbg.select_tab(ctx, "food")      # keeps target ON while active
      F4     -> dbg.select_tab(ctx, "behavior")
      F5     -> dbg.select_tab(ctx, "swim")
    """
    def __init__(self, context):
        self.context = context
        self._tank_eid: Optional[int] = None
        dbg.ensure_defaults(self.context)
    def set_world_ref(self, world): pass
    def set_tank(self, tank_entity: int): self._tank_eid = tank_entity
    def handle_textinput(self, event): pass
    def handle_keydown(self, event): self.handle_event(event)
    def handle_event(self, event):
        if event.type != pygame.KEYDOWN:
            return
        k = event.key
        if k == pygame.K_SPACE:
            tp = getattr(self.context, "toggle_pause", None)
            tp() if callable(tp) else setattr(self.context, "paused",
                   not bool(getattr(self.context, "paused", False)))
            return
        if k == pygame.K_l:
            begin = getattr(self.context, "begin_label_edit", None)
            if callable(begin): begin()
            else: setattr(self.context, "edit_tank_label",
                          not bool(getattr(self.context, "edit_tank_label", False)))
            return
        if   k == pygame.K_F1: dbg.select_tab(self.context, "legend");   return
        elif k == pygame.K_F2: dbg.select_tab(self.context, "motion");   return
        elif k == pygame.K_F3: dbg.select_tab(self.context, "food");     return
        elif k == pygame.K_F4: dbg.select_tab(self.context, "behavior"); return
        elif k == pygame.K_F5: dbg.select_tab(self.context, "swim");     return
    def update(self, world, dt): return
```
# === FILE END: ecs\systems\ui\keyboard_system.py ===
# === FILE START: ecs\systems\ui\mouse_system.py ===
```python
# ecs/systems/ui/mouse_system.py
from __future__ import annotations
from typing import Optional, Iterable, Tuple
import pygame
LMB = 1
RMB = 3
class MouseSystem:
    """
    Mouse-up driven + Panels:
    - LMB-up: panels consume first; then toolbar toggles; then fish hit → open a panel.
    - RMB-up: close top-most panel if present, else global cancel for tools & legacy modals.
    """
    def __init__(self, context, screen, assets):
        self.context = context
        self.screen = screen
        self.assets = assets
        self._tank_entity: Optional[int] = None
        self._world = None
        self._placement = None
        self._panels = None  # PanelManagerSystem
    # wiring
    def set_tank(self, entity_id: int) -> None: self._tank_entity = entity_id
    def set_world_ref(self, world) -> None: self._world = world
    def set_placement(self, placement_system) -> None: self._placement = placement_system
    def set_panel_manager(self, panel_manager) -> None: self._panels = panel_manager
    # utils
    def _point_in_tank_screen(self, x: int, y: int) -> bool:
        sx = int(getattr(self.context, "tank_screen_x", 0))
        sy = int(getattr(self.context, "tank_screen_y", 0))
        sw = int(getattr(self.context, "tank_screen_w", self.screen.get_width()))
        sh = int(getattr(self.context, "tank_screen_h", self.screen.get_height()))
        return (sx <= x <= sx + sw) and (sy <= y <= sy + sh)
    def _deactivate_all_tools(self) -> None:
        if getattr(self.context, "feeding_enabled", False): self.context.feeding_enabled = False
        if getattr(self.context, "egging_enabled", False): self.context.egging_enabled = False
    def _clear_cursor_and_selection(self) -> None:
        ctx = self.context
        for name in ("active_tool", "cursor_tool", "selected_entity",
                     "selected_card", "selected_item", "hover_entity",
                     "hover_card", "hover_widget", "tooltip", "pending_action"):
            if hasattr(ctx, name): setattr(ctx, name, None)
        for name in ("dragging", "is_dragging", "is_panning", "rubberband_active"):
            if hasattr(ctx, name): setattr(ctx, name, False)
        if hasattr(ctx, "cursor_mode"): ctx.cursor_mode = "default"
        for name in ("ui_place_egg", "ui_drop_pellets", "ui_click", "ui_drag", "ui_hover"):
            if hasattr(ctx, name): setattr(ctx, name, None)
    def _cancel_all_ui(self, mx: int, my: int) -> None:
        self.context.ui_cancel = {"x": int(mx), "y": int(my), "button": RMB}
        self._deactivate_all_tools()
        self._clear_cursor_and_selection()
        for flag in ("show_fish_window", "show_fish_inspector"):
            if hasattr(self.context, flag): setattr(self.context, flag, False)
    def _hit_test_fish(self, mx: int, my: int) -> Optional[int]:
        rects: Iterable[Tuple[int, pygame.Rect]] = getattr(self.context, "fish_screen_rects", []) or []
        for eid, rect in reversed(list(rects)):
            if rect.collidepoint(mx, my):
                return eid
        return None
    # events
    def handle_mouse_event(self, event: pygame.event.Event) -> None:
        if event.type == pygame.MOUSEBUTTONUP:
            mx, my = pygame.mouse.get_pos()
            btn = getattr(event, "button", 0)
            if btn == RMB:
                # NEW: prefer closing the top-most panel if present
                if self._panels and hasattr(self._panels, "close_top_panel") and self._panels.close_top_panel():
                    self._deactivate_all_tools()  # why: consistent with cancel semantics
                    return
                self._cancel_all_ui(mx, my)
                return
            self._on_mouse_up(event)
        elif event.type == pygame.MOUSEWHEEL:
            mx, my = pygame.mouse.get_pos()
            self.context.ui_wheel_event = {"x": int(mx), "y": int(my), "dy": int(event.y)}
    def _on_mouse_up(self, event: pygame.event.Event) -> None:
        mx, my = event.pos
        if event.button != LMB:
            return
        # Panels consume first
        if self._panels and self._panels.consume_click(mx, my):
            return
        # Toolbar toggles
        feed_btn = getattr(self.context, "toolbar_button_rect", None)
        egg_btn  = getattr(self.context, "toolbar_egg_rect", None)
        fish_btn = getattr(self.context, "fish_button_rect", None)
        if feed_btn and feed_btn.collidepoint(mx, my):
            on = not bool(getattr(self.context, "feeding_enabled", False))
            self.context.feeding_enabled = on
            if on: self.context.egging_enabled = False
            return
        if egg_btn and egg_btn.collidepoint(mx, my):
            on = not bool(getattr(self.context, "egging_enabled", False))
            self.context.egging_enabled = on
            if on: self.context.feeding_enabled = False
            return
        if fish_btn and fish_btn.collidepoint(mx, my):
            self._deactivate_all_tools()
            show = bool(getattr(self.context, "show_fish_window", False))
            self.context.show_fish_window = not show
            self.context.show_fish_inspector = False
            return
        # Placement
        tool_on = bool(getattr(self.context, "feeding_enabled", False) or getattr(self.context, "egging_enabled", False))
        if tool_on and self._point_in_tank_screen(mx, my):
            if self._placement and hasattr(self._placement, "enqueue_click"):
                self._placement.enqueue_click(mx, my)
            return
        # Fish pick → open a floating panel
        if not tool_on and self._point_in_tank_screen(mx, my):
            hit = self._hit_test_fish(mx, my)
            if hit is not None and self._panels and self._world:
                self._deactivate_all_tools()
                self.context.show_fish_window = False
                self.context.show_fish_inspector = False
                self._panels.open_fish(self._world, hit, at=(mx, my))
            return
    def update(self, world, dt) -> None:
        return
```
# === FILE END: ecs\systems\ui\mouse_system.py ===
# === FILE START: ecs\systems\ui\placement_system.py ===
```python
from __future__ import annotations
from typing import List, Tuple, Optional
import random
from ecs.components.core.position_component import Position
from ecs.components.core.sprite_component import Sprite
from ecs.components.core.tank_ref_component import TankRef
from ecs.components.tags.food_pellet_component import FoodPellet
from ecs.components.tags.affected_by_gravity import AffectedByGravity
from ecs.components.fish.age_component import Age
from ecs.components.fish.brain_component import Brain
from ecs.components.core.velocity_component import Velocity
class PlacementSystem:
    """
    Receives screen-space clicks (via enqueue_click) and spawns pellets or eggs
    based on the current tool state in context.
    MouseSystem calls:
        placement.enqueue_click(x, y)
    This system then processes them during update(...) so spawns happen the same
    frame (after UI handling).
    Also exposes `spawn_egg_at(world, x_logical, y_logical, species_id=None)` so
    gameplay systems (breeding) can spawn “the same egg” as the EGG tool.
    """
    def __init__(self, context):
        self.context = context
        self._tank_entity: Optional[int] = None
        self._pending_clicks: List[Tuple[int, int]] = []
    def set_tank(self, tank_entity: int) -> None:
        self._tank_entity = tank_entity
    def enqueue_click(self, x: int, y: int) -> None:
        self._pending_clicks.append((int(x), int(y)))
    # -------------------- helpers --------------------
    def _point_in_tank_screen(self, x: int, y: int) -> bool:
        sx = int(getattr(self.context, "tank_screen_x", 0))
        sy = int(getattr(self.context, "tank_screen_y", 0))
        sw = int(getattr(self.context, "tank_screen_w", 0))
        sh = int(getattr(self.context, "tank_screen_h", 0))
        return (sx <= x <= sx + sw) and (sy <= y <= sy + sh)
    def _spawn_pellet(self, world, x: int, y: int) -> None:
        if self._tank_entity is None:
            return
        scale = float(getattr(self.context, "tank_scale", 1.0) or 1.0)
        sx = int(getattr(self.context, "tank_screen_x", 0))
        sy = int(getattr(self.context, "tank_screen_y", 0))
        sw = int(getattr(self.context, "tank_screen_w", 0))
        sh = int(getattr(self.context, "tank_screen_h", 0))
        if not (sx <= x <= sx + sw and sy <= y <= sy + sh):
            return
        cfg = self.context.pellets or {}
        image_id = cfg.get("sprite", "pellet")
        w = int(cfg.get("width", 16))
        h = int(cfg.get("height", 16))
        nutrition = float(cfg.get("nutrition", 40.0))
        radius_scale = float(cfg.get("radius_scale", 1.0))
        off_x = float(cfg.get("center_offset_x", 0.0))
        off_y = float(cfg.get("center_offset_y", 0.0))
        fall_speed = float(cfg.get("fall_speed", 60.0))
        logical_x = (x - sx) / scale
        logical_y = (y - sy) / scale
        e = world.create_entity()
        world.add_component(e, TankRef(self._tank_entity))
        world.add_component(e, Position(logical_x, logical_y))
        world.add_component(e, Sprite(image_id=image_id, base_w=w, base_h=h))
        world.add_component(e, FoodPellet(nutrition=nutrition, radius_scale=radius_scale,
                                          center_off_x=off_x, center_off_y=off_y))
        world.add_component(e, AffectedByGravity(speed=fall_speed))
        audio = getattr(self.context, "audio", None)
        if audio:
            audio.play("pellet_drop")
    # -------------------- SPAWN EGG (click) --------------------
    def _spawn_egg(self, world, click_x: int, click_y: int) -> None:
        """Same as before, but routed through spawn_egg_at for single source of truth."""
        if not getattr(self.context, "egging_enabled", False):
            return
        if self._tank_entity is None:
            return
        scale = float(getattr(self.context, "tank_scale", 1.0))
        tank_pos = world.get_component(self._tank_entity, Position)
        if tank_pos is None or scale <= 0.0:
            return
        sx, sy = tank_pos.x, tank_pos.y
        sw = int(getattr(self.context, "tank_screen_w", 0))
        sh = int(getattr(self.context, "tank_screen_h", 0))
        if not (sx <= click_x <= sx + sw and sy <= click_y <= sy + sh):
            return
        logical_x = (click_x - sx) / scale
        logical_y = 0.0  # eggs fall from the top (tool behavior)
        # Delegate to shared path (random species like the tool normally does)
        self.spawn_egg_at(world, logical_x, logical_y, species_id=None)
    # -------------------- SPAWN EGG (programmatic) --------------------
    def spawn_egg_at(self, world, x_logical: float, y_logical: float, species_id: Optional[str] = None) -> None:
        """
        Programmatic logical egg spawn used by CourtshipSystem and others.
        This mirrors the EGG tool path: create a full fish via factory, then
        force Egg stage + gravity so all downstream systems (aging, UI) see it.
        """
        if self._tank_entity is None:
            return
        # Choose species (given or random from config)
        species_map = getattr(self.context, "species_config", {}) or {}
        if not species_map:
            return
        if species_id is None:
            species_id = random.choice(list(species_map.keys()))
        sdata = species_map.get(species_id)
        if not sdata:
            return
        from ecs.factories.fish_factory import create_fish
        e = create_fish(world, self.context, self._tank_entity, species_id, sdata, float(x_logical), float(y_logical))
        # Force Egg stage visuals/physics (WHY: ensure same as the tool; keeps window + aging consistent)
        age = world.get_component(e, Age)
        if age:
            age.stage = "Egg"
            age.age = 0.0
            age.pre_hatch = 0.0
        brain = world.get_component(e, Brain)
        if brain:
            brain.state = "Egg"
            brain.current_desired_speed = 0.0
        vel = world.get_component(e, Velocity)
        if vel:
            vel.dx = 0.0
            vel.dy = 0.0
        if world.get_component(e, AffectedByGravity) is None:
            fall_speed = float((getattr(self.context, "balancing", {}) or {}).get("egg_fall_speed", 55.0))
            world.add_component(e, AffectedByGravity(speed=fall_speed))
        audio = getattr(self.context, "audio", None)
        if audio:
            audio.play("pellet_drop")
    # -------------------- ECS entry --------------------
    def update(self, world, dt: float) -> None:
        if not self._pending_clicks:
            return
        # Process in FIFO order; each click spawns either egg or pellet.
        while self._pending_clicks:
            click_x, click_y = self._pending_clicks.pop(0)
            if getattr(self.context, "egging_enabled", False):
                self._spawn_egg(world, click_x, click_y)
            elif getattr(self.context, "feeding_enabled", False):
                self._spawn_pellet(world, click_x, click_y)
        # done
```
# === FILE END: ecs\systems\ui\placement_system.py ===
# === FILE START: ecs\systems\ui\ui_toolbar_system.py ===
```python
# ecs/systems/ui_toolbar_system.py
import pygame
class UIToolbarSystem:
    """
    Draws a bottom-left toolbar with two toggles:
      - Feed (pellet)
      - Egg (egg_icon.png)
    Writes rectangles to context for InputSystem hit-test.
    """
    def __init__(self, screen, assets, context):
        self.screen = screen
        self.assets = assets
        self.context = context
    def _draw_button(self, x, y, size, on, icon_surf):
        rect = pygame.Rect(x, y, size, size)
        bg = (240, 210, 60) if on else (30, 30, 30)
        border = (200, 220, 255) if on else (140, 140, 140)
        pygame.draw.rect(self.screen, bg, rect, border_radius=8)
        pygame.draw.rect(self.screen, border, rect, width=2, border_radius=8)
        if icon_surf:
            pad = max(4, size // 8)
            iw = ih = size - pad * 2
            icon = pygame.transform.smoothscale(icon_surf, (iw, ih))
            self.screen.blit(icon, (x + pad, y + pad))
        return rect
    def update(self, world, dt):
        ui = self.context.ui or {}
        size = int(ui.get("ui_toolbar_button_size", 48))
        mx   = int(ui.get("ui_toolbar_margin_x", 12))
        my   = int(ui.get("ui_toolbar_margin_y", 12))
        sw, sh = self.screen.get_size()
        # Layout: [Feed] [Egg] from left
        x_feed = mx
        y = sh - my - size
        x_egg = x_feed + size + mx // 2
        # Feed button
        feed_on = bool(getattr(self.context, "feeding_enabled", False))
        feed_icon = self.assets.get("pellet")
        feed_rect = self._draw_button(x_feed, y, size, feed_on, feed_icon)
        self.context.toolbar_button_rect = feed_rect
        # Egg button
        egg_on = bool(getattr(self.context, "egging_enabled", False))
        egg_icon = self.assets.get("egg_icon") or self.assets.get("egg")  # fallback
        egg_rect = self._draw_button(x_egg, y, size, egg_on, egg_icon)
        self.context.toolbar_egg_rect = egg_rect
```
# === FILE END: ecs\systems\ui\ui_toolbar_system.py ===
# === FILE START: ecs\systems\ui\debug\__init__.py ===
```python
```
# === FILE END: ecs\systems\ui\debug\__init__.py ===
# === FILE START: ecs\systems\ui\debug\debug_controller.py ===
```python
# ecs/systems/ui/debug/debug_controller.py
from __future__ import annotations
# Public API ---------------------------------------------------------------
def ensure_defaults(ctx) -> None:
    """Idempotent defaults for menus + overlay flags."""
    _def(ctx, "show_debug_menu", False)     # F1
    _def(ctx, "show_motion_menu", False)    # F2
    _def(ctx, "show_food_menu", False)      # F3
    _def(ctx, "show_behavior_menu", False)  # F4
    _def(ctx, "show_swim_menu", False)      # F5
    # Movement
    _def(ctx, "show_target_lines", False)
    _def(ctx, "show_velocity_arrows", False)
    _def(ctx, "show_avoidance_arrows", False)
    # Food
    _def(ctx, "show_food_debug", False)  # umbrella if some renderers use it
    _def(ctx, "show_fish_vision", False)
    _def(ctx, "show_pellet_radius", False)
    _def(ctx, "show_food_links", False)
    # Behavior
    _def(ctx, "show_behavior_labels", False)
    _def(ctx, "show_stats_bars", False)
    # Swim
    _def(ctx, "show_swim_floor_debug", False)
def select_tab(ctx, tab: str) -> None:
    """
    Mutually-exclusive selection with toggle behavior.
    Allowed tabs: "legend","motion","food","behavior","swim".
    Behavior:
      - Pressing a new tab clears all overlays + opens that tab's menu + turns on its overlays.
      - Pressing the same tab again closes its menu and clears overlays (including target in food).
      - Food keeps target lines ON while active (exception only when turning food ON).
    """
    ensure_defaults(ctx)
    # Toggle off if this tab is already open
    if _is_tab_open(ctx, tab):
        _clear_all_menus(ctx)
        _clear_all_overlays(ctx)  # closes menu => overlays off
        return
    # Open requested tab: clear, then enable this tab
    _clear_all_menus(ctx)
    _clear_all_overlays(ctx)
    if tab == "legend":
        ctx.show_debug_menu = True
        return
    if tab == "motion":
        ctx.show_motion_menu = True
        ctx.show_target_lines = True
        ctx.show_velocity_arrows = True
        ctx.show_avoidance_arrows = True
        return
    if tab == "food":
        ctx.show_food_menu = True
        ctx.show_food_debug = True
        ctx.show_fish_vision = True
        ctx.show_pellet_radius = True
        ctx.show_food_links = True
        ctx.show_target_lines = True  # exception: keep target ON during food
        return
    if tab == "behavior":
        ctx.show_behavior_menu = True
        ctx.show_behavior_labels = True
        ctx.show_stats_bars = True
        return
    if tab == "swim":
        ctx.show_swim_menu = True
        ctx.show_swim_floor_debug = True
        return
# Internals ---------------------------------------------------------------
def _def(ctx, name, value):
    if not hasattr(ctx, name):
        setattr(ctx, name, value)
def _clear_all_menus(ctx):
    ctx.show_debug_menu = False
    ctx.show_motion_menu = False
    ctx.show_food_menu = False
    ctx.show_behavior_menu = False
    ctx.show_swim_menu = False
def _clear_all_overlays(ctx):
    # Movement
    ctx.show_target_lines = False
    ctx.show_velocity_arrows = False
    ctx.show_avoidance_arrows = False
    # Food
    ctx.show_food_debug = False
    ctx.show_fish_vision = False
    ctx.show_pellet_radius = False
    ctx.show_food_links = False
    # Behavior
    ctx.show_behavior_labels = False
    ctx.show_stats_bars = False
    # Swim
    ctx.show_swim_floor_debug = False
def _is_tab_open(ctx, tab: str) -> bool:
    if tab == "legend":   return bool(getattr(ctx, "show_debug_menu", False))
    if tab == "motion":   return bool(getattr(ctx, "show_motion_menu", False))
    if tab == "food":     return bool(getattr(ctx, "show_food_menu", False))
    if tab == "behavior": return bool(getattr(ctx, "show_behavior_menu", False))
    if tab == "swim":     return bool(getattr(ctx, "show_swim_menu", False))
    return False
```
# === FILE END: ecs\systems\ui\debug\debug_controller.py ===
# === FILE START: ecs\systems\ui\debug\debug_menu.py ===
```python
# ecs/systems/ui/debug/debug_menu.py
import pygame
# ---------- Colors aligned with overlay drawers ----------
# Motion overlay
CLR_TARGET   = (255, 200, 0)   # target line
CLR_VELOCITY = (255, 255, 0)   # velocity arrow
CLR_AVOID    = (255, 100, 0)   # avoidance arrow
# Food overlay
CLR_VISION   = (0, 200, 255)   # vision ring
CLR_PELLET_R = (120, 230, 255) # pellet/seek radius
CLR_EAT_R    = (80, 200, 255)  # eat threshold radius
# Behavior overlay (bars)
CLR_BAR_BG   = (60, 60, 60)
CLR_HUNGER   = (255, 210, 80)
CLR_HEALTH   = (100, 255, 120)
# Age gradient endpoints
CLR_AGE_START = (120, 200, 255)
CLR_AGE_END   = (255, 140, 60)
class DebugMenu:
    """
    Small F-key debug panels (F1..F5). Text-only; overlays render elsewhere.
    IMPORTANT: Supports BOTH selection models:
      1) New: context.debug_panel_mode in {"legend","motion","food","behavior","swim", None}
      2) Legacy: show_debug_menu/show_motion_menu/show_food_menu/show_behavior_menu/show_swim_menu
    If debug_panel_mode is present, it takes precedence.
    Otherwise, it derives the mode from legacy flags.
    """
    PAD = 10
    GAP = 6
    LINE_GAP = 6
    BG = (0, 0, 0, 160)
    TXT = (235, 240, 255)
    def __init__(self, screen, context):
        self.screen = screen
        self.context = context
        self._fonts = {}
    # ---- font helpers ----
    def _font(self, px: int) -> pygame.font.Font:
        if px not in self._fonts:
            self._fonts[px] = pygame.font.SysFont("consolas, menlo, courier new, monospace", int(px))
        return self._fonts[px]
    def _ui_sizes(self):
        base = int(getattr(self.context, "ui", {}).get("ui_font_size", 14))
        return base + 2, base + 6  # body, title
    # ---- active mode resolution (new or legacy) ----
    def _active_mode(self):
        # Preferred: unified mode string
        mode = getattr(self.context, "debug_panel_mode", None)
        if mode in ("legend", "motion", "food", "behavior", "swim"):
            return mode
        # Legacy flags fallback (first true wins; you can tweak priority if needed)
        if bool(getattr(self.context, "show_debug_menu", False)):     return "legend"
        if bool(getattr(self.context, "show_motion_menu", False)):    return "motion"
        if bool(getattr(self.context, "show_food_menu", False)):      return "food"
        if bool(getattr(self.context, "show_behavior_menu", False)):  return "behavior"
        if bool(getattr(self.context, "show_swim_menu", False)):      return "swim"
        return None
    # ---- content builders ----
    def _build_items(self):
        mode = self._active_mode()
        if not mode:
            return []
        body_px, title_px = self._ui_sizes()
        f_body = self._font(body_px)
        f_title = self._font(title_px)
        items = []
        def t(text: str):
            return ("text", f_body.render(text, True, self.TXT), self.TXT)
        def title(text: str):
            return ("text", f_title.render(text, True, self.TXT), self.TXT)
        def line(label: str, color):
            return ("line", f_body.render(label, True, self.TXT), color)
        def gradient(label: str, c0, c1, bg=CLR_BAR_BG):
            return ("gradient", f_body.render(label, True, self.TXT), (c0, c1, bg))
        if mode == "legend":
            items += [
                title("F1 - LEGEND"),
                t("SPACE – Pause/Unpause"),
                t("L     – Edit tank label"),
                t("F1    – This Menu"),
                t("F2    – Movement debug (target/velocity/avoidance)"),
                t("F3    – Food debug (vision/pellet/link)"),
                t("F4    – Behavior labels & bars"),
                t("F5    – Toggle swim-area overlay"),
                t("F6    – Breeding (Not Implemented)"),
            ]
        elif mode == "motion":
            items += [
                title("F2 - MOVEMENT DEBUG"),
                line("Target line ----------------", CLR_TARGET),
                line("Velocity arrow -------------", CLR_VELOCITY),
                line("Avoidance arrows -----------", CLR_AVOID),
            ]
        elif mode == "food":
            items += [
                title("F3 - FOOD DEBUG"),
                line("Vision radius --------------", CLR_VISION),
                line("Pellet radius --------------", CLR_PELLET_R),
                line("Eat threshold --------------", CLR_EAT_R),
                line("Target line ----------------", CLR_TARGET),  # kept ON in food mode
            ]
        elif mode == "behavior":
            items += [
                title("F4 - BEHAVIOR OVERLAY"),
                line("Hunger bar -----------------", CLR_HUNGER),
                line("Health bar -----------------", CLR_HEALTH),
                gradient("Age bar --------------------", CLR_AGE_START, CLR_AGE_END, CLR_BAR_BG),
            ]
        elif mode == "swim":
            items += [
                title("F5 - SWIM AREA OVERLAY"),
                t("Visualizes fall floor vs swim bottom; see tank for colors."),
            ]
        return items
    # ---- render ----
    def _render_items(self, items):
        if not items:
            return
        pad = self.PAD
        line_gap = self.LINE_GAP
        # measure
        max_w = 0
        total_h = 0
        for kind, surf, _ in items:
            h = max(16, surf.get_height()) if kind in ("line", "gradient") else surf.get_height()
            total_h += h + line_gap
            max_w = max(max_w, surf.get_width())
        total_h -= line_gap
        box_w = pad * 2 + 16 + 8 + max_w
        box_h = pad * 2 + total_h
        x, y = 10, 10
        bg = pygame.Surface((box_w, box_h), pygame.SRCALPHA)
        bg.fill(self.BG)
        self.screen.blit(bg, (x, y))
        cy = y + pad
        for kind, surf, payload in items:
            if kind == "text":
                self.screen.blit(surf, (x + pad, cy))
                cy += surf.get_height() + line_gap
                continue
            swx = x + pad
            row_h = max(16, surf.get_height())
            swy = cy + (row_h // 2) - 1
            if kind == "line":
                color = payload
                pygame.draw.line(self.screen, color, (swx, swy), (swx + 16, swy), width=3)
                self.screen.blit(surf, (swx + 16 + 8, cy))
                cy += row_h + line_gap
            elif kind == "gradient":
                c0, c1, bgc = payload
                gw, gh = 32, 8
                gsurf = pygame.Surface((gw, gh), pygame.SRCALPHA)
                pygame.draw.rect(gsurf, bgc, (0, 0, gw, gh))
                for i in range(gw):
                    t = i / max(1, gw - 1)
                    r = int(c0[0] + (c1[0] - c0[0]) * t)
                    g = int(c0[1] + (c1[1] - c0[1]) * t)
                    b = int(c0[2] + (c1[2] - c0[2]) * t)
                    pygame.draw.line(gsurf, (r, g, b), (i, 0), (i, gh), 1)
                self.screen.blit(gsurf, (swx, swy - gh // 2))
                self.screen.blit(surf, (swx + gw + 8, cy))
                cy += row_h + line_gap
    # ---- ECS entry ----
    def update(self, world, dt):
        items = self._build_items()
        if not items:
            return
        self._render_items(items)
```
# === FILE END: ecs\systems\ui\debug\debug_menu.py ===
# === FILE START: ecs\systems\ui\debug\debug_overlay_system.py ===
```python
# ecs/systems/ui/debug/debug_overlay_system.py
import pygame
class DebugOverlaySystem:
    """
    Only draws the Swim Area overlay (visualizes fall floor vs swim bottom).
    Text menus/legend are handled by DebugMenu (F1..F5) elsewhere.
    Controlled by: context.show_swim_floor_debug (bool)
    """
    _CLR_SWIM_WASH    = (80, 240, 120, 28)
    _CLR_EXT_WASH     = (80, 160, 255, 40)
    _CLR_BLOCK_WASH   = (200, 50, 50, 90)
    _CLR_SWIM_OUTLINE = (80, 240, 120)
    _CLR_FALL_FLOOR   = (255, 255, 255)
    _CLR_SWIM_BOTTOM  = (255, 200, 0)
    def __init__(self, screen, context):
        self.screen = screen
        self.context = context
    def _tank_rect_px(self):
        x = int(getattr(self.context, "tank_screen_x", 0))
        y = int(getattr(self.context, "tank_screen_y", 0))
        w = int(getattr(self.context, "tank_screen_w", self.screen.get_width()))
        h = int(getattr(self.context, "tank_screen_h", self.screen.get_height()))
        return x, y, max(0, w), max(0, h)
    def _ratio_or_px(self, px, ratio, y, h):
        if px is not None and px >= 0:
            return int(px)
        r = 1.0 if ratio is None else max(0.0, min(1.0, float(ratio)))
        return int(round(y + h * r))
    def _fall_floor_y(self, x, y, w, h):
        sand_px = getattr(self.context, "sand_top_px", None)
        sand_ratio = getattr(self.context, "sand_top_ratio", 1.0)
        return self._ratio_or_px(sand_px, sand_ratio, y, h)
    def _swim_bottom_y(self, x, y, w, h, fall_floor_y: int):
        sb_px = getattr(self.context, "swim_bottom_px", None)
        sb_ratio = getattr(self.context, "swim_bottom_ratio", None)
        if sb_px is not None or sb_ratio is not None:
            val = self._ratio_or_px(sb_px, sb_ratio, y, h)
        else:
            val = fall_floor_y + int(round(h * 0.06))
        val = max(y, min(y + h, val))
        return max(val, fall_floor_y)
    def update(self, world, dt):
        if not bool(getattr(self.context, "show_swim_floor_debug", False)):
            return
        x, y, w, h = self._tank_rect_px()
        if w <= 0 or h <= 0:
            return
        fall_y = self._fall_floor_y(x, y, w, h)
        swim_y = self._swim_bottom_y(x, y, w, h, fall_y)
        swim_main_h = max(0, fall_y - y)
        swim_ext_h  = max(0, swim_y - fall_y)
        block_h     = max(0, (y + h) - swim_y)
        if swim_main_h > 0:
            pygame.draw.rect(self.screen, self._CLR_SWIM_OUTLINE, pygame.Rect(x, y, w, swim_main_h), width=2)
            wash = pygame.Surface((w, swim_main_h), pygame.SRCALPHA)
            wash.fill(self._CLR_SWIM_WASH)
            self.screen.blit(wash, (x, y))
        if swim_ext_h > 0:
            ext = pygame.Surface((w, swim_ext_h), pygame.SRCALPHA)
            ext.fill(self._CLR_EXT_WASH)
            self.screen.blit(ext, (x, fall_y))
        if block_h > 0:
            blk = pygame.Surface((w, block_h), pygame.SRCALPHA)
            blk.fill(self._CLR_BLOCK_WASH)
            self.screen.blit(blk, (x, swim_y))
        pygame.draw.line(self.screen, self._CLR_FALL_FLOOR, (x, fall_y), (x + w, fall_y), width=1)
        pygame.draw.line(self.screen, self._CLR_SWIM_BOTTOM, (x, swim_y), (x + w, swim_y), width=1)
```
# === FILE END: ecs\systems\ui\debug\debug_overlay_system.py ===
# === FILE START: ecs\systems\ui\debug\fish_info_system.py ===
```python
# # ecs/systems/ui/fish_info_system.py
# import pygame
# from typing import Optional
#
# from ecs.systems.ui.widgets.modal_window import ModalWindow
# from ecs.components.fish.age_component import Age
# from ecs.components.fish.health_component import Health
# from ecs.components.fish.species_component import Species
#
# class FishInfoSystem:
#     """
#     Opens a modal info card when `context.show_fish_info` is True and
#     `context.selected_entity` is set. Closes via RMB/ESC (handled by ModalWindow).
#     """
#     PAD_X = 18
#     PAD_Y = 10
#     LINE = 26
#
#     def __init__(self, screen: pygame.Surface, assets, context):
#         self.screen = screen
#         self.assets = assets
#         self.context = context
#         self.modal = ModalWindow(screen, context)
#         self._font_small = pygame.font.SysFont("arial", 16)
#         self._font_med = pygame.font.SysFont("arial", 18)
#
#     def _get(self, world, ent, comp_type):
#         try:
#             return world.get_component(ent, comp_type)
#         except Exception:
#             try:
#                 return world.components.get(comp_type, {}).get(ent)
#             except Exception:
#                 return None
#
#     def update(self, world, dt: float) -> None:
#         if not getattr(self.context, "show_fish_info", False):
#             return
#         ent = getattr(self.context, "selected_entity", None)
#         if ent is None:
#             return
#
#         species: Optional[Species] = self._get(world, ent, Species)
#         age: Optional[Age] = self._get(world, ent, Age)
#         health: Optional[Health] = self._get(world, ent, Health)
#
#         title = (species.display_name if (species and getattr(species, "display_name", None)) else "Fish")
#         win_rect, content_view, close_rect, title_surf = self.modal.open(title)
#
#         x = content_view.x + self.PAD_X
#         y = content_view.y + self.PAD_Y
#
#         lines = []
#         if species:
#             lines.append(("Species ID:", species.species_id))
#         if age:
#             lines.append(("Stage:", getattr(age, "stage", "Unknown")))
#             lines.append(("Age:", f"{getattr(age, 'age', 0.0):.1f} / {getattr(age, 'lifespan', 0.0):.1f}"))
#         if health:
#             lines.append(("Health:", f"{getattr(health, 'value', 0.0):.0f}/{getattr(health, 'max_value', 0.0):.0f}"))
#
#         for label, value in lines:
#             lbl = self._font_small.render(str(label), True, (180, 190, 210))
#             val = self._font_med.render(str(value), True, (235, 240, 255))
#             self.screen.blit(lbl, (x, y))
#             self.screen.blit(val, (x + 120, y))
#             y += self.LINE
#
#         # Mirror modal state to show flag
#         if not self.modal.is_open():
#             self.context.show_fish_info = False
#
#     def handle_event(self, event: pygame.event.Event) -> None:
#         self.modal.handle_event(event)
```
# === FILE END: ecs\systems\ui\debug\fish_info_system.py ===
# === FILE START: ecs\systems\ui\widgets\__init__.py ===
```python
```
# === FILE END: ecs\systems\ui\widgets\__init__.py ===
# === FILE START: ecs\systems\ui\widgets\grid_layout.py ===
```python
from typing import Tuple
class CardGrid:
    """Compute grid geometry for fixed-size cards."""
    def __init__(self, card_w: int, card_h: int, gutter_x: int, gutter_y: int):
        self.card_w = card_w
        self.card_h = card_h
        self.gx = gutter_x
        self.gy = gutter_y
    def measure(self, view_w: int, count: int) -> Tuple[int, int, int]:
        cols = max(1, (view_w + self.gx) // (self.card_w + self.gx))
        total_w = int(cols) * self.card_w + int(cols - 1) * self.gx
        grid_x = max(0, (view_w - total_w) // 2)
        rows = (count + cols - 1) // cols if count else 0
        return int(cols), int(rows), int(grid_x)
    def pos(self, index: int, cols: int, grid_x: int) -> Tuple[int, int]:
        row = index // cols
        col = index % cols
        x = grid_x + col * (self.card_w + self.gx)
        y = row * (self.card_h + self.gy)
        return x, y
```
# === FILE END: ecs\systems\ui\widgets\grid_layout.py ===
# === FILE START: ecs\systems\ui\widgets\modal_window.py ===
```python
# ecs/systems/ui/widgets/modal_window.py
import pygame
from typing import Tuple
class ModalWindow:
    """
    Simple modal shell used by FishWindowSystem.
    Contract:
      - open(title) draws the panel and returns:
          (win_rect, content_view_rect, close_rect, title_surface)
      - Sets context.ui_modal_active and ui_modal_whitelist = [close_rect]
      - Exposes rects back on context for MouseSystem strict-modal gating:
          context.fish_window_rect, context.fish_close_rect
    WHY this shape: FishWindowSystem expects this API and immediately unpacks
    the 4-tuple to layout its scrollable content and wire the close hitbox.
    """
    def __init__(self, screen: pygame.Surface, ctx) -> None:
        self.screen = screen
        self.ctx = ctx
        self._fonts: dict[int, pygame.font.Font] = {}
        # Visual style
        self.margin = 20
        self.pad = 28
        self.title_gap = 18
        self.bg_rgba = (10, 15, 22, 200)
        self.border = (220, 230, 255)
        self.close_size = 32
        self.close_pad = 14
    # --- font helpers ---
    def _font(self, px: int) -> pygame.font.Font:
        f = self._fonts.get(px)
        if f is None:
            f = pygame.font.SysFont("arial", int(px))
            self._fonts[px] = f
        return f
    def _ui_title_px(self) -> int:
        # WHY: keep title size tied to global UI base for consistency
        base = int((getattr(self.ctx, "ui", {}) or {}).get("ui_font_size", 14))
        return base + 10
    # --- public API expected by FishWindowSystem ---
    def open(self, title: str) -> Tuple[pygame.Rect, pygame.Rect, pygame.Rect, pygame.Surface]:
        sw, sh = self.screen.get_size()
        # Outer window rect (full-screen inset)
        win_rect = pygame.Rect(self.margin, self.margin, sw - self.margin * 2, sh - self.margin * 2)
        # Panel background
        panel = pygame.Surface((win_rect.w, win_rect.h), pygame.SRCALPHA)
        panel.fill(self.bg_rgba)
        self.screen.blit(panel, (win_rect.x, win_rect.y))
        pygame.draw.rect(self.screen, self.border, win_rect, width=2)
        # Title
        title_font = self._font(self._ui_title_px())
        title_surf = title_font.render(title, True, (235, 240, 255))
        self.screen.blit(title_surf, (win_rect.x + self.pad, win_rect.y + self.pad))
        # Close button rect (top-right inside the panel)
        close_rect = pygame.Rect(
            win_rect.x + win_rect.w - self.close_pad - self.close_size,
            win_rect.y + self.close_pad,
            self.close_size,
            self.close_size,
        )
        self._draw_close(close_rect)
        # Client/content viewport (below title)
        inner_x = win_rect.x + self.pad
        inner_y = win_rect.y + self.pad + title_surf.get_height() + self.title_gap
        inner_w = win_rect.w - self.pad * 2
        inner_h = win_rect.h - (inner_y - win_rect.y) - self.pad
        content_view = pygame.Rect(inner_x, inner_y, inner_w, max(0, inner_h))
        # Strict modal lock for MouseSystem (only allow clicks on close/X while open)
        self.ctx.ui_modal_active = True
        self.ctx.ui_modal_whitelist = [close_rect]
        # Expose rects back to context so MouseSystem can hit-test and toggle the flag
        self.ctx.fish_window_rect = win_rect
        self.ctx.fish_close_rect = close_rect
        return win_rect, content_view, close_rect, title_surf
    # --- chrome ---
    def _draw_close(self, rect: pygame.Rect) -> None:
        mx, my = pygame.mouse.get_pos()
        hover = rect.collidepoint(mx, my)
        bg = (40, 45, 60) if not hover else (55, 60, 80)
        xcol = (240, 90, 100)
        pygame.draw.rect(self.screen, bg, rect, border_radius=8)
        # Draw an "X"
        pad = 9
        x1, y1 = rect.x + pad, rect.y + pad
        x2, y2 = rect.right - pad, rect.bottom - pad
        pygame.draw.line(self.screen, xcol, (x1, y1), (x2, y2), width=3)
        pygame.draw.line(self.screen, xcol, (x1, y2), (x2, y1), width=3)
```
# === FILE END: ecs\systems\ui\widgets\modal_window.py ===
# === FILE START: ecs\systems\ui\widgets\panel.py ===
```python
# ecs/systems/ui/widgets/panel.py
from __future__ import annotations
import pygame
from dataclasses import dataclass
from typing import Callable, Optional, Tuple, Union
Color = Union[Tuple[int, int, int], Tuple[int, int, int, int]]
@dataclass
class InspectorPanel:
    """Floating panel widget state (reusable, animatable)."""
    id: int
    kind: str            # e.g., "fish"
    title: str
    x: int
    y: int
    w: int
    h: int
    z: int
    entity: Optional[int] = None
    render_body: Optional[Callable[[pygame.Surface, pygame.Rect], None]] = None
    # updated per-frame (exported by renderer)
    close_rect: Optional[pygame.Rect] = None
    header_rect: Optional[pygame.Rect] = None
    body_rect: Optional[pygame.Rect] = None
    # animation targets/state (managed by PanelManagerSystem)
    tx: Optional[int] = None           # target x
    ty: Optional[int] = None           # target y
    ax0: Optional[int] = None          # anim start x
    ay0: Optional[int] = None          # anim start y
    anim_start_ms: Optional[int] = None
    anim_dur_ms: int = 0
    anim_kind: Optional[str] = None    # "drop" | "shift" | None
@dataclass
class PanelTheme:
    radius: int = 10
    pad: int = 12
    gap_rows: int = 6
    gap_cols: int = 12
    line_h: int = 20
    title_pad_h: int = 2
    min_w: int = 200
    max_w: int = 360
    bg: Color = (28, 34, 48, 235)
    border: Color = (180, 195, 215)
    title_color: Color = (235, 240, 255)
    label_color: Color = (180, 190, 210)
    value_color: Color = (235, 240, 255)
    close_bg: Color = (60, 65, 80)
    close_fg: Color = (220, 120, 130)
class PanelRenderer:
    """Draws a rounded floating panel and delegates body to a callback."""
    def __init__(self, screen: pygame.Surface, theme: Optional[PanelTheme] = None):
        self.screen = screen
        self.theme = theme or PanelTheme()
        self._font_cache: dict[int, pygame.font.Font] = {}
    def font(self, px: int) -> pygame.font.Font:
        f = self._font_cache.get(px)
        if f is None:
            f = pygame.font.SysFont("arial", int(px))
            self._font_cache[px] = f
        return f
    def draw(self, panel: InspectorPanel, title_px: int) -> None:
        t = self.theme
        font_title = self.font(title_px)
        ts = font_title.render(panel.title, True, t.title_color)
        title_h = ts.get_height() + t.title_pad_h
        panel_rect = pygame.Rect(panel.x, panel.y, panel.w, panel.h)
        header_rect = pygame.Rect(panel_rect.x + t.pad, panel_rect.y + t.pad,
                                  panel_rect.w - 2 * t.pad, title_h)
        close_size = 18
        close_rect = pygame.Rect(panel_rect.right - t.pad - close_size,
                                 panel_rect.y + t.pad, close_size, close_size)
        body_y = header_rect.bottom + t.gap_rows
        body_rect = pygame.Rect(panel_rect.x + t.pad, body_y,
                                panel_rect.w - 2 * t.pad, panel_rect.bottom - t.pad - body_y)
        # Rounded fill + border
        bg = pygame.Surface((panel_rect.w, panel_rect.h), pygame.SRCALPHA)
        pygame.draw.rect(bg, t.bg, bg.get_rect(), border_radius=t.radius)
        self.screen.blit(bg, (panel_rect.x, panel_rect.y))
        pygame.draw.rect(self.screen, t.border, panel_rect, width=1, border_radius=t.radius)
        # Title and close
        self.screen.blit(ts, (header_rect.x, header_rect.y))
        pygame.draw.rect(self.screen, t.close_bg, close_rect, border_radius=6)
        cx = self.font(max(12, title_px - 4)).render("×", True, t.close_fg)
        self.screen.blit(cx, (close_rect.x + (close_rect.w - cx.get_width()) // 2,
                              close_rect.y + (close_rect.h - cx.get_height()) // 2))
        # Body content
        if callable(panel.render_body):
            panel.render_body(self.screen, body_rect)
        # Export rects
        panel.close_rect = close_rect
        panel.header_rect = header_rect
        panel.body_rect = body_rect
    @staticmethod
    def clamp_to_screen(rect: pygame.Rect, screen_size: Tuple[int, int]) -> None:
        sw, sh = screen_size
        rect.x = min(max(0, rect.x), max(0, sw - rect.w))
        rect.y = min(max(0, rect.y), max(0, sh - rect.h))
```
# === FILE END: ecs\systems\ui\widgets\panel.py ===
# === FILE START: ecs\systems\ui\widgets\panel_manager_system.py ===
```python
# ecs/systems/ui/widgets/panel_manager_system.py
from __future__ import annotations
import pygame
from typing import List, Optional, Tuple, Dict, Any
from ecs.systems.ui.widgets.panel import InspectorPanel, PanelRenderer, PanelTheme
from ecs.systems.ui.widgets.thumb_provider import ThumbProvider
from ecs.systems.renderers.cache import SpriteCache  # same cache used elsewhere
# Components (normal runtime imports)
from ecs.components.core.sprite_component import Sprite
from ecs.components.fish.age_component import Age
from ecs.components.fish.brain_component import Brain
from ecs.components.fish.health_component import Health
from ecs.components.fish.species_component import Species
from ecs.components.fish.hunger_component import Hunger
class PanelManagerSystem:
    """
    Floating inspector panels manager (non-modal):
    - Panels snap to a compact top-left grid.
    - Drop/shift animation is visual-only; logical (x,y) stays on the grid.
    - **Portraits are cached per entity by stage**; on stage transition we rebuild once via ThumbProvider.
    - RMB close (top-most) supported via close_top_panel(); LMB hits handled by consume_click().
    """
    THUMB_BOX = 72
    def __init__(self, screen: pygame.Surface, assets, context):
        self.screen = screen
        self.assets = assets
        self.context = context
        self.theme = PanelTheme()
        self.renderer = PanelRenderer(screen, self.theme)
        self.thumbs = ThumbProvider(self.assets, self.context)
        if not hasattr(self.context, "ui_panels"):
            self.context.ui_panels: List[InspectorPanel] = []
        self._z_next = 1
        # Grid geometry
        self._grid_cell_w = max(self.theme.min_w, 260)
        self._grid_cell_h = 160
        self._grid_gap_x = 10
        self._grid_gap_y = 10
        self._grid_margin_x = 12
        self._grid_margin_y = 12
        self._grid_cols: Optional[int] = None
        self._grid_rows: Optional[int] = None
        # ---- NEW: portrait cache keyed by entity id ----
        # value: {"stage": str|None, "surf": pygame.Surface}
        self._portrait_cache: Dict[int, Dict[str, Any]] = {}
    # ---------- Public API ----------
    def open_fish(self, world, entity: int, at: Optional[Tuple[int, int]] = None) -> None:
        # Focus if already open
        for p in self.context.ui_panels:
            if p.kind == "fish" and p.entity == entity:
                p.z = self._z_alloc()
                return
        title = self._fish_title(world, entity)
        idx = len(self.context.ui_panels)
        tx, ty = self._grid_slot_xy(idx)
        panel = InspectorPanel(
            id=self._z_next, kind="fish", entity=entity, title=title,
            x=tx, y=ty, w=self._grid_cell_w, h=self._grid_cell_h, z=self._z_alloc(),
            render_body=lambda surf, body: self._render_fish_body(world, entity, surf, body),
        )
        panel.tx, panel.ty = tx, ty
        # Visual drop (logical x,y already snapped for tests)
        now = pygame.time.get_ticks()
        panel.anim_kind = "drop"
        panel.ax0, panel.ay0 = tx, ty - 28
        panel.anim_start_ms = now
        panel.anim_dur_ms = 220
        self.context.ui_panels.append(panel)
        # Seed cache on open (so first draw is correct without waiting a frame)
        self._ensure_portrait(world, entity)
    def consume_click(self, mx: int, my: int) -> bool:
        if not self.context.ui_panels:
            return False
        for p in sorted(self.context.ui_panels, key=lambda p: p.z, reverse=True):
            rect = pygame.Rect(p.x, p.y, p.w, p.h)
            if rect.collidepoint(mx, my):
                if p.close_rect and p.close_rect.collidepoint(mx, my):
                    self._remove_panel(p)
                    return True
                p.z = self._z_alloc()
                return True
        return False
    def close_top_panel(self) -> bool:
        if not self.context.ui_panels:
            return False
        top = max(self.context.ui_panels, key=lambda p: p.z)
        self._remove_panel(top)
        return True
    # Optional external invalidation if some system wants to force-refresh
    def invalidate_thumb(self, eid: int) -> None:
        self._portrait_cache.pop(int(eid), None)
    # ---------- Internal: Grid ----------
    def _z_alloc(self) -> int:
        self._z_next += 1
        return self._z_next
    def _compute_grid_dims(self) -> None:
        sw, sh = self.screen.get_size()
        usable_w = max(0, sw - self._grid_margin_x * 2)
        usable_h = max(0, sh - self._grid_margin_y * 2)
        cols = max(1, (usable_w + self._grid_gap_x) // (self._grid_cell_w + self._grid_gap_x))
        rows = max(1, (usable_h + self._grid_gap_y) // (self._grid_cell_h + self._grid_gap_y))
        self._grid_cols = int(cols)
        self._grid_rows = int(rows)
    def _grid_slot_xy(self, idx: int) -> Tuple[int, int]:
        if self._grid_cols is None or self._grid_rows is None:
            self._compute_grid_dims()
        col = idx % self._grid_cols
        row = idx // self._grid_cols
        x = self._grid_margin_x + col * (self._grid_cell_w + self._grid_gap_x)
        y = self._grid_margin_y + row * (self._grid_cell_h + self._grid_gap_y)
        return int(x), int(y)
    def _reflow_grid(self) -> None:
        if not self.context.ui_panels:
            return
        self._compute_grid_dims()
        ordered = sorted(self.context.ui_panels, key=lambda p: p.id)
        now = pygame.time.get_ticks()
        for i, p in enumerate(ordered):
            tx, ty = self._grid_slot_xy(i)
            moved = (getattr(p, "tx", p.x) != tx) or (getattr(p, "ty", p.y) != ty)
            if moved:
                p.anim_kind = "shift"
                p.ax0, p.ay0 = p.x, p.y
                p.anim_start_ms = now
                p.anim_dur_ms = 200
            p.tx, p.ty = tx, ty
            p.x, p.y = tx, ty
        self.context.ui_panels[:] = ordered
    # ---------- Render ----------
    def update(self, world, dt: float) -> None:
        if not self.context.ui_panels:
            return
        base = int((getattr(self.context, "ui", {}) or {}).get("ui_font_size", 14))
        title_px = base + 6
        now = pygame.time.get_ticks()
        for p in sorted(self.context.ui_panels, key=lambda p: p.z):
            eff_x, eff_y = p.x, p.y
            if getattr(p, "anim_kind", None) and getattr(p, "anim_start_ms", None) is not None:
                t = (now - p.anim_start_ms) / max(1, getattr(p, "anim_dur_ms", 1))
                if t >= 1.0:
                    p.anim_kind = None
                    p.ax0 = p.ay0 = None
                    p.anim_start_ms = None
                    p.anim_dur_ms = 0
                else:
                    u = 1.0 - (1.0 - t) ** 3
                    ax0 = getattr(p, "ax0", p.x)
                    ay0 = getattr(p, "ay0", p.y)
                    eff_x = int(ax0 + (p.tx - ax0) * u)
                    eff_y = int(ay0 + (p.ty - ay0) * u)
            r = pygame.Rect(eff_x, eff_y, p.w, p.h)
            self.renderer.clamp_to_screen(r, self.screen.get_size())
            ox, oy = p.x, p.y
            p.x, p.y = r.x, r.y
            self.renderer.draw(p, title_px)
            p.x, p.y = ox, oy
    # ---------- Helpers & Body Rendering ----------
    def _remove_panel(self, p: InspectorPanel) -> None:
        try:
            self.context.ui_panels.remove(p)
        except ValueError:
            return
        # drop portrait cache entry so reopening starts clean
        self._portrait_cache.pop(int(getattr(p, "entity", -1)), None)
        self._reflow_grid()
    def _fish_title(self, world, eid: int) -> str:
        sp: Optional[Species] = world.get_component(eid, Species)
        return str(sp.display_name) if sp and getattr(sp, "display_name", None) else "Fish"
    def _fit_aspect(self, w: int, h: int, box_px: int) -> Tuple[int, int]:
        if w <= 0 or h <= 0 or box_px <= 0:
            return box_px, box_px
        scale = min(box_px / float(w), box_px / float(h))
        return int(w * scale), int(h * scale)
    # ---- Portrait cache keyed by stage -------------------------------------
    def _current_stage_and_brain(self, world, eid: int) -> Tuple[Optional[str], Optional[str]]:
        age: Optional[Age] = world.get_component(eid, Age)
        brain: Optional[Brain] = world.get_component(eid, Brain)
        stage = getattr(age, "stage", None)
        brain_state = getattr(brain, "state", None)
        return stage, brain_state
    def _ensure_portrait(self, world, eid: int) -> pygame.Surface:
        """
        Ensure we have a portrait surface cached for the entity's **current stage**.
        If stage changed versus cache, rebuild once via ThumbProvider to mirror card rules.
        """
        stage, brain_state = self._current_stage_and_brain(world, eid)
        cached = self._portrait_cache.get(int(eid))
        if cached and cached.get("stage") == stage:
            return cached["surf"]
        # Build through ThumbProvider to match your card behavior.
        # Try the most specific signature first; fall back gracefully.
        surf: Optional[pygame.Surface] = None
        try:
            surf = self.thumbs.card_thumb(world, eid, self.THUMB_BOX, stage=stage, brain_state=brain_state)
        except TypeError:
            try:
                surf = self.thumbs.card_thumb(world, eid, self.THUMB_BOX)
            except Exception:
                surf = None
        except Exception:
            surf = None
        # If ThumbProvider doesn't have card_thumb, try common alternates
        if surf is None and hasattr(self.thumbs, "build_fish_thumb"):
            try:
                surf = self.thumbs.build_fish_thumb(world, eid, self.THUMB_BOX, stage=stage, brain_state=brain_state)
            except TypeError:
                try:
                    surf = self.thumbs.build_fish_thumb(world, eid, self.THUMB_BOX)
                except Exception:
                    surf = None
            except Exception:
                surf = None
        if surf is None and hasattr(self.thumbs, "thumb_for_entity"):
            try:
                surf = self.thumbs.thumb_for_entity(world, eid, self.THUMB_BOX, stage=stage, brain_state=brain_state)
            except TypeError:
                try:
                    surf = self.thumbs.thumb_for_entity(world, eid, self.THUMB_BOX)
                except Exception:
                    surf = None
            except Exception:
                surf = None
        # Final fallback: scale species/sprite base so we always show something.
        if surf is None:
            sp: Optional[Species] = world.get_component(eid, Species)
            spr: Optional[Sprite] = world.get_component(eid, Sprite)
            key = getattr(spr, "image", None) or getattr(sp, "species_id", None)
            base = self.assets.get(key) if key else None
            if not isinstance(base, pygame.Surface):
                base = pygame.Surface((self.THUMB_BOX, self.THUMB_BOX), pygame.SRCALPHA)
                base.fill((60, 60, 60, 255))
            bw, bh = base.get_size()
            tw, th = self._fit_aspect(bw, bh, self.THUMB_BOX)
            surf = pygame.transform.smoothscale(base, (tw, th))
        # Store/replace cache
        self._portrait_cache[int(eid)] = {"stage": stage, "surf": surf}
        return surf
    def _render_fish_body(self, world, eid: int, surf: pygame.Surface, body: pygame.Rect) -> None:
        """
        Left column: 72x72 portrait (cached by stage, rebuilt via ThumbProvider on change).
        Right column: quick facts.
        """
        # Portrait (cached by stage)
        thumb = self._ensure_portrait(world, eid)
        tw, th = thumb.get_size()
        thumb_x = body.x
        thumb_y = body.y + max(0, (self.THUMB_BOX - th) // 2)
        surf.blit(thumb, (thumb_x, thumb_y))
        # Info column
        pad = 10
        info_x = body.x + self.THUMB_BOX + pad
        info_w = max(0, body.w - self.THUMB_BOX - pad)
        info_rect = pygame.Rect(info_x, body.y, info_w, body.h)
        base = int((getattr(self.context, "ui", {}) or {}).get("ui_font_size", 14))
        font = self.renderer.font(base)
        sp: Optional[Species] = world.get_component(eid, Species)
        age: Optional[Age] = world.get_component(eid, Age)
        br: Optional[Brain] = world.get_component(eid, Brain)
        hp: Optional[Health] = world.get_component(eid, Health)
        hg: Optional[Hunger] = world.get_component(eid, Hunger)
        def _fmt_pct(v, mx) -> str:
            try:
                return f"{int(round(100.0 * float(v) / max(1.0, float(mx))))}%"
            except Exception:
                return "-"
        lines = [
            f"Species: {getattr(sp, 'display_name', 'Unknown')}",
            f"Stage:   {getattr(age, 'stage', 'Unknown')}",
            f"Age:     {int(getattr(age, 'age', 0.0))}/{int(getattr(age, 'lifespan', 0.0))}",
            f"Health:  {int(getattr(hp, 'value', 0.0))}/{int(getattr(hp, 'max_value', 0.0))}",
            f"Hunger:  {int(getattr(hg, 'hunger', 0.0))}/{int(getattr(hg, 'hunger_max', 100.0))} ({_fmt_pct(getattr(hg,'hunger',0.0), getattr(hg,'hunger_max',100.0))})",
            f"Brain:   {getattr(br, 'state', 'Unknown')}",
        ]
        y = info_rect.y
        for text in lines:
            s = font.render(text, True, (230, 235, 245))
            surf.blit(s, (info_rect.x, y))
            y += s.get_height() + 4
```
# === FILE END: ecs\systems\ui\widgets\panel_manager_system.py ===
# === FILE START: ecs\systems\ui\widgets\scrollbox.py ===
```python
# ecs/systems/ui/widgets/scrollbox.py
import pygame
from typing import Optional
class ScrollBox:
    """
    Offscreen content with vertical scrolling + track/thumb drawing + drag handling.
    Supports mouse wheel via on_wheel(delta_px).
    Usage:
      - sync(content_h, view_h)
      - draw_scrollbar(screen, track_rect)
      - handle_mouse(track_rect)          # drag thumb
      - on_wheel(delta_px)                # wheel scroll (+down, -up)
    """
    def __init__(self):
        self.scroll_y = 0.0
        self.content_h = 0
        self.view_h = 0
        self.min_thumb = 24
        self.wheel_step_px = 60  # one wheel notch
        self._drag = False
        self._start_y = 0
        self._start_scroll = 0.0
        self._prev_mb1 = False
    def sync(self, content_h: int, view_h: int):
        self.content_h = int(max(0, content_h))
        self.view_h = int(max(0, view_h))
        self.scroll_y = max(0.0, min(float(max(0, self.content_h - self.view_h)), self.scroll_y))
    def on_wheel(self, delta_px: float):
        """Positive delta scrolls DOWN; negative scrolls UP."""
        if self.content_h <= self.view_h:
            self.scroll_y = 0.0
            return
        max_scroll = float(self.content_h - self.view_h)
        self.scroll_y = max(0.0, min(max_scroll, self.scroll_y + float(delta_px)))
    def thumb_rect(self, track: pygame.Rect) -> pygame.Rect:
        if self.content_h <= self.view_h or self.view_h <= 0:
            return pygame.Rect(track.x, track.y, track.w, track.h)
        ratio = self.view_h / self.content_h
        th = max(self.min_thumb, int(track.h * ratio))
        max_scroll = self.content_h - self.view_h
        t = 0.0 if max_scroll <= 0 else (self.scroll_y / max_scroll)
        travel = track.h - th
        ty = track.y + int(travel * t)
        return pygame.Rect(track.x, ty, track.w, th)
    def draw_scrollbar(self, screen, track: pygame.Rect, track_col=(60,70,90), thumb_col=(160,175,200)):
        pygame.draw.rect(screen, track_col, track, border_radius=5)
        if self.content_h > self.view_h:
            pygame.draw.rect(screen, thumb_col, self.thumb_rect(track), border_radius=5)
    def handle_mouse(self, track: pygame.Rect):
        mb1 = pygame.mouse.get_pressed(num_buttons=3)[0]
        mx, my = pygame.mouse.get_pos()
        if mb1 and not self._prev_mb1 and self.content_h > self.view_h:
            if self.thumb_rect(track).collidepoint(mx, my):
                self._drag = True
                self._start_y = my
                self._start_scroll = self.scroll_y
        if self._drag:
            dy = my - self._start_y
            thumb = self.thumb_rect(track)
            travel = max(1, track.h - thumb.h)
            if travel > 0 and self.content_h > self.view_h:
                ratio = (self.content_h - self.view_h) / travel
                self.scroll_y = self._start_scroll + dy * ratio
                max_scroll = max(0, self.content_h - self.view_h)
                self.scroll_y = max(0.0, min(float(max_scroll), self.scroll_y))
        if not mb1:
            self._drag = False
        self._prev_mb1 = mb1
```
# === FILE END: ecs\systems\ui\widgets\scrollbox.py ===
# === FILE START: ecs\systems\ui\widgets\thumb_provider.py ===
```python
# file: ecs/systems/ui/widgets/thumb_provider.py
import pygame
from typing import Optional, Dict, Any, Tuple
from ecs.components.core.sprite_component import Sprite
from ecs.components.fish.age_component import Age
from ecs.components.fish.brain_component import Brain
from ecs.components.fish.health_component import Health
from ecs.systems.renderers.cache import SpriteCache
class ThumbProvider:
    """
    Card thumbnails:
      - Egg: show egg icon.
      - Juvenile: 50% of adult fit (aspect kept).
      - Adult: 100% fit (aspect kept).
      - Senior: desat/tint style (variant="senior").
      - Dead: grayscale + upside-down (dead=True), no hflip.
    """
    def __init__(self, assets, context) -> None:
        self.assets = assets
        self.context = context
        self.cache = SpriteCache.shared()
        # (image_key, stage, dead/alive, box_px) -> Surface
        self._local: Dict[Tuple[str, str, str, int], pygame.Surface] = {}
    def _senior_style_cfg(self) -> Dict[str, Any]:
        aging = getattr(self.context, "aging", {}) or {}
        return {
            "desaturate": float(aging.get("senior_desaturate", 0.6)),
            "tint": tuple(aging.get("senior_tint", [235, 225, 215])),
            "outline": bool(aging.get("senior_outline", True)),
            "outline_px": int(aging.get("senior_outline_px", 1)),
            "outline_color": tuple(aging.get("senior_outline_color", [40, 35, 30, 255])),
        }
    def _fit_aspect(self, bw: int, bh: int, box_px: int) -> Tuple[int, int]:
        # keep aspect; fit the larger dimension to box
        scale = min(float(box_px) / max(1.0, float(bw)),
                    float(box_px) / max(1.0, float(bh)))
        return max(1, int(round(bw * scale))), max(1, int(round(bh * scale)))
    def get(
        self,
        spr: Sprite,
        age: Optional[Age],
        brain: Optional[Brain],
        health: Optional[Health],
        box_px: int
    ) -> Optional[pygame.Surface]:
        stage = (getattr(age, "stage", "Adult") or "Adult").lower()
        is_egg = (stage == "egg")
        is_juvenile = (stage == "juvenile")
        is_senior = (stage == "senior")
        is_dead = (getattr(brain, "state", "") or "").lower() == "dead"
        key_img = spr.image_id if not is_egg else "egg"
        key = (key_img, stage, "dead" if is_dead else "alive", int(box_px))
        if key in self._local:
            return self._local[key]
        # ---- Egg: use egg sprite directly ----
        if is_egg:
            egg_img = self.assets.get("egg")
            if not isinstance(egg_img, pygame.Surface):
                return None
            w, h = egg_img.get_size()
            tw, th = self._fit_aspect(w, h, box_px)
            surf = self.cache.get(
                egg_img, tw, th,
                dead=False, hflip=False,
                variant="normal", senior_style=None
            )
            if surf is not None:
                self._local[key] = surf
            return surf
        # ---- Non-egg: base species sprite ----
        base = self.assets.get(spr.image_id)
        if not isinstance(base, pygame.Surface):
            return None
        # Adult fit inside box with aspect; e.g., 60x40 @ 72px -> 72x48
        adult_w, adult_h = self._fit_aspect(base.get_width(), base.get_height(), box_px)
        # Juvenile is exactly half of adult geometry
        final_w = max(1, adult_w // 2) if is_juvenile else adult_w
        final_h = max(1, adult_h // 2) if is_juvenile else adult_h
        # Senior style only when alive
        variant = "senior" if (is_senior and not is_dead) else "normal"
        style = self._senior_style_cfg() if variant == "senior" else None
        # Single-pass build so the first smoothscale matches expected size
        surf = self.cache.get(
            base,
            final_w, final_h,
            dead=is_dead,
            hflip=False,
            variant=variant,
            senior_style=style
        )
        if surf is not None:
            self._local[key] = surf
        return surf
```
# === FILE END: ecs\systems\ui\widgets\thumb_provider.py ===
